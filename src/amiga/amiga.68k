*
*	Amiga-specific portions of Pengo
*
* (c) JOTD 2023
*

.include "../src/karate_champ.inc"
.include "custom.i"
.include "exec_lvos.i"
.include "dos_lvos.i"
.include "graphics_lvos.i"

AttnFlags = 0x128
AFB_68010 = 0
AFB_68020 = 1
NO68020 = 1


SCREEN_ADDRESS = 0xD000


SCORE_FILE_SIZE = 0x1E



	.ifdef	RELEASE
OPT_ENABLE_PROFILING = 0         | DO NOT CHANGE THIS
OPT_ENABLE_LOGGING = 0           | DO NOT CHANGE THIS
ONE_TICK = 1
	* check most used options in release mode
	* to avoid creating a version with cheats on!
	.ifne	OPT_DISABLE_BG_LAYER
	.error	"debug option OPT_DISABLE_BG_LAYER in release mode"
	.endif
	.ifne	OPT_DISABLE_SPRITES
	.error	"debug option OPT_DISABLE_SPRITES in release mode"
	.endif
	.ifne	OPT_SKIP_TITLE_SCREEN
	.error	"nonzero OPT_SKIP_TITLE_SCREEN option in release mode"
	.endif
	.ifne	OPT_ONLY_ONE_LIFE
	.error	"nonzero OPT_ONLY_ONE_LIFE option in release mode"
	.endif
	.ifne	OPT_SKIP_GAME_DEMO
	.error	"nonzero OPT_SKIP_GAME_DEMO option in release mode"
	.endif
	.ifne	OPT_START_SCORE
	.error	"nonzero OPT_START_SCORE option in release mode"
	.endif

	.else
OPT_ENABLE_LOGGING = 1
OPT_ENABLE_PROFILING = 0
* set to higher values than 1 to speed game up
ONE_TICK = 1

	.endif
	

OPT_ENABLE_DOUBLE_BUFFERING_BG = 1

_custom = 0xDFF000


NB_PLAYFIELD_PLANES = 4
TOTAL_NB_COLORS = 16   | 8+8+16
NB_BYTES_PER_ROW = 40
NB_LINES = 288
Y_MAX = NB_LINES
NB_PLAYFIELD_LINES = NB_LINES

BG_SCREEN_PLANE_SIZE = NB_BYTES_PER_ROW*NB_PLAYFIELD_LINES
BG_SCREEN_SIZE =  BG_SCREEN_PLANE_SIZE*NB_PLAYFIELD_PLANES
FG_SCREEN_PLANE_SIZE = BG_SCREEN_PLANE_SIZE
FG_SCREEN_SIZE =  FG_SCREEN_PLANE_SIZE*NB_PLAYFIELD_PLANES


NB_HOST_SPRITES = 8
NB_TARGET_SPRITES = 64

SPRITE_X = 0
SPRITE_Y = 1
SPRITE_CODE = 2
SPRITE_CLUT = 3
SPRITE_SIZEOF = 4



| write current PC value to some address
.macro LOGPC	address
	.ifndef	RELEASE
     bsr    .next_\@
.next_\@:
      addq.l    #6,(a7) | skip this & next instruction
      move.l    (a7)+,0x\address
	.endif
.endm

.macro	WAIT_BLIT
	move.w	#0x8400,(dmacon,a5)		| blitter high priority
wait\@:
	BTST	#6,(dmaconr,a5)
	BNE.S	wait\@
	move.w	#0x0400,(dmacon,a5)		| blitter normal priority
.endm

.macro MUL_TABLE value,len
mul\value\()_table:
	.set    mulv,0
	.rept	\len
	dc.w	mulv
	.set	mulv,mulv+\value
	.endr
.endm


* debug macro that colors the screen until LMB pressed
.macro 	blitz_bypass
	move.w	d0,-(a7)
	clr.w	d0
loop\@:
	move.w	d0,_custom+color
	btst	#6,0xbfe001
	beq.b	out\@
	addq.w	#1,d0
	bra.b	loop\@
out\@:
	move.w	(a7)+,d0
	nop
.endm

* same thing but if LMB is pressed when entering, macro waits for release)
.macro blitz
w\@:
	btst	#6,0xbfe001
	beq.b	w\@
	blitz_bypass
.endm

	move.l	a7,old_stack
	bra	_user



* exports

	  .global _user
		.global _player_start
		.global _demo_end

* osd layer		
		.global osd_enable_vblank_interrupt
		.global osd_ack_vblank_interrupt
		.global osd_disable_vblank_interrupt
		.global osd_break		| for debug	
		*.global osd_calibrate_display		| for debug
		.global osd_w_videoram
		.global osd_w_colorram
		.global osd_r_videoram
		.global osd_r_colorram
		.global osd_update_sprites
		.global osd_read_dipswitches
		.global osd_small_wait
		.global osd_read_inputs
		.global osd_read_high_scores
		.global osd_write_high_scores
		.global osd_get_sync_period
		.global osd_sound_start
		.global osd_sound_stop
		.global osd_sound_enable
		.global osd_sound_disable


	
	.include	"ReadJoypad.i"
	.include	"whdload_funcs.i"
		.text


.list

	.ifne	OPT_ENABLE_PROFILING
	* init profiling if enabled
	.include	"profiler.68k"
	.endif

	    
_user:
    * if D0 contains "WHDL"
    * A0 contains resload
        
    cmp.l   #0x05748444c,D0	| WHDL
    bne.b   .standard
    move.l a0,_resload

	move.l	a0,a2
	lea	(_tag,pc),a0
	jsr	(resload_Control,a2)
	
    bra		.no_forbid
.standard:
	
    * open dos library, graphics library
    move.l  0x4.W,a6
    lea dosname,a1
    moveq.l #0,d0
    jsr _LVOOpenLibrary(a6)
    move.l  d0,_dosbase

	lea	read_args_string(pc),a0
	lea	program_args(pc),a1
	move.l	#program_args_end-program_args,d0
	lsr.l	#2,d0		| number of longs
	
	bsr	get_args_BCPL

0:	
	lea		program_args,a0

	move.l	(A0)+,D0	| INVINCIBLE/S
	beq.b	1f
	or.l	#1,cheat_flags
	st.b	cheat_used
1:
	move.l	(A0)+,D0	| INFLIVES/S
	beq.b	2f
	or.l	#2,cheat_flags
	st.b	cheat_used
2:
	move.l	(A0)+,D0	| CHEATKEYS/S
	beq.b	2f
	* cheat isn't used as long as no cheat key is used
	or.l	#4,cheat_flags
2:
	move.l	(A0)+,D0	| STARTLEVEL/S
	beq.b	2f
	bsr		bcpl_string_to_int
	subq	#1,d0
	move.l	d0,start_level_option

2:
	moveq.l	#0,d7


	move.l	(A0)+,D0	| BAT50000/S
	beq.b	2f
	bset	#0,d7
2:
	move.l	(A0)+,D0	| QUICKMAZEDRAW/S
	beq.b	2f
	bset	#1,d7
2:

	move.l	(A0)+,D0	| NOINTERMISSIONS/S
	beq.b	2f
	bset	#2,d7
2:

	move.l	(A0)+,D0	| ALTMUSIC/S
	beq.b	2f
	bset	#3,d7
2:

	move.l	(A0)+,D0	| SKILL/S
	beq.b	2f
	bsr		bcpl_string_to_int
	move.l	d0,dip_switch_difficulty
2:
	
	move.l	d7,misc_options
	
	bsr		store_system
	
	lea		_custom,a5
	lea		debug_copperlist,a0
	move.l	a0,cop1lc(a5)

	
	move.l	4.W,A6
	lea graphicsname,a1
    moveq.l #0,d0
    jsr _LVOOpenLibrary(a6)
    move.l  d0,_gfxbase
    move.l	d0,a6
	move.l	38(a6),old_syscoplist
	move.l	34(A6),old_actiview		| gb_ActiView

	sub.l	a1,a1
	jsr	_LVOLoadView(a6)
	jsr	_LVOWaitTOF(a6)
	jsr	_LVOWaitTOF(a6)

	bsr		load_highscores

    * check if "floppy" file is here
    
    move.l  _dosbase(pc),a6
    move.l   #floppy_file,d1
    move.l  #1005,d2   | MODE_OLDFILE
    jsr     _LVOOpen(a6)
    move.l  d0,d1
    beq.b   .no_floppy
    
    * "floppy" file found
    jsr     _LVOClose(a6)
    * wait 2 seconds for floppy drive to switch off
    move.l  #100,d1
    jsr     _LVODelay(a6)
.no_floppy:

.startup:

* no multitask
    tst.l   _resload
    bne.b   .no_forbid
    *move.l  _gfxbase(pc),a4
    *move.l StartList(a4),gfxbase_copperlist

    move.l  4,a6
    jsr _LVOForbid(a6)

    
	sub.l	A1,A1
	jsr	_LVOFindTask(a6)		| find ourselves
	move.l	D0,A0
	move.l	#-1,184(A0)	| pr_WindowPtr: no more system requesters (insert volume, write protected...)

.no_forbid:
	
	move.l	dip_switch_difficulty(pc),d0
	lsl.b	#3,d0		| to match what game expects
	
	not.b	d0		| active low
	move.b	d0,dip_switches

*	btst	#1,d1
*	sne.b	quick_maze_draw_flag
*	btst	#2,d1
*	sne.b	no_intermissions_flag
*	btst	#3,d1
*	sne.b	alternate_music_flag
	
	move.l	start_level_option(pc),d0
	cmp.w	#24,d0
	bcc.b	0f
	move.b	d0,start_level		| 0-23 => 1-24
0:

*	move.l	cheat_flags,d0
*	btst	#0,d0
*	sne		invincible_flag
*	btst	#1,cheat_flags
*	sne		infinite_lives_flag
	
	
	jsr	 _detect_controller_types 

	jra		demo_game


* < D0: bcpl string (with leading size byte)
* < A1: dest C string
bcpl_arg_string_copy:
    movem.l D0-D2/A0-A1,-(a7)
	lsl.l	#2,d0
	moveq.l	#0,d2
    move.l  d0,a0
	move.b	(a0)+,d2	| size
	beq.b	1f
	subq	#1,d2
0:
	move.b	(a0)+,(a1)+
	dbf		d2,0b
1:
    movem.l (a7)+,D0-D2/A0-A1
    rts


bcpl_string_to_int:
    movem.l A0/A1,-(a7)
    lea temp_filename_buffer(pc),a1
    bsr bcpl_arg_string_copy
    * convert to integer
    move.l  a1,a0
    * < A0: pointer on C string
    * > D0: value
    * > D1: -1 if ok, position of the string if error
    bsr parse_integer
    movem.l  (a7)+,a0/a1
	rts
	
* parse integer from string
* < A0: pointer on C string
* > D0: value
* > D1: -1 if ok, position of the string if error
parse_integer:
    movem.l  d2/d3,-(a7)
    * go to end of string
    moveq.l #-1,d1
.loop1:
    addq.l  #1,d1
    tst.b   (a0,d1.w)
    bne.b   .loop1
    * d1 is the number of chars
    moveq.l #0,d0
    moveq.l #0,d2
    subq.l  #2,d1   | 10th power minus 1
.loop2:
    move.b  (a0)+,d2
    beq.b   .out
    
    cmp.b   #32,d2
    beq.b   .skip
    sub.b   #48,d2
    bcs.b   .error
    cmp.b   #10,d2
    bcc.b   .error
    move.w  d1,d3
    bmi.b   .doadd
.muloop:
    mulu    #10,d2
    dbf d3,.muloop
.doadd:
    add.l   d2,d0
.skip:
    subq.l  #1,d1
    bra.b   .loop2
.out:    
    movem.l  (a7)+,d2/d3
    rts
.error:
    moveq.l #0,d0
    bra.b   .error
	
    * thanks Toni for this 1.3 read argument code
BCPL_RdArgs = 78
	
	* a1 = pointer to result array. Must be LONG aligned!
	* a0 = formatting string. BSTR!
	* d0 = size of result array (number of LONGs)
get_args_BCPL:
	movem.l d2/d3/d4,-(sp)
	move.l d0,d3
	moveq #BCPL_RdArgs,d0
	move.l a0,d1
	lsr.l #2,d1
	move.l a1,d2
	lsr.l #2,d2
	moveq #0,d4
	bsr.s call_bcpl
	movem.l (sp)+,d2/d3/d4
	rts

	* d0 = gv index
	* d1-d4 = bcpl parms

BCPL_STACK = 3000

call_bcpl:
	movem.l d2-d7/a2-a6,-(sp)

	move.l d0,d6
	move.l d1,d5

	move.l 4.w,a6
	move.l	_dosbase(pc),a5


	sub.l a1,a1
	jsr	_LVOFindTask(a6)
	move.l d0,a4

	* allocate BCPL stack
	move.l #BCPL_STACK,d0
	move.l #65536+1,d1
	jsr	_LVOAllocMem(a6)
	move.l d0,d7
	beq.s 0f
	
	movem.l d7/a5/a6,-(sp)

	moveq #0,d0
	move.l d5,d1
	sub.l a0,a0
	move.l d7,a1
	lea 3*4(a1),a1
	move.l 136(a4),a2
	lsl.w #2,d6
	move.l 0(a2,d6.w),a4
	movem.l 46(a5),a5/a6
	jsr (a5) | call bcpl!
	
	movem.l (sp)+,d7/a5/a6

0:
	move.l d7,a1
	move.l #BCPL_STACK,d0
	jsr	_LVOFreeMem(a6)


	movem.l (sp)+,d2-d7/a2-a6
	rts


	
get_hiscore_name:
    lea normal_hiscorename,a0
	rts
	
load_highscores:
	bsr.b		get_hiscore_name
    move.l  _resload(pc),d0
    bne.b   1f

    move.l  _dosbase(pc),a6
    move.l  a0,d1
    move.l  #1005,d2
    jsr     (_LVOOpen,a6)
    move.l  d0,d1
    beq.b   1f
    move.l  d1,d4
    move.l  #SCORE_FILE_SIZE,d3
    move.l  #high_score_buffer,d2
    jsr (_LVORead,a6)
    move.l  d4,d1
    jsr (_LVOClose,a6)   
	st.b	highscore_loaded
1:
    rts

save_highscores:
	tst.l	_resload
	bne.b	1f
    tst.b   highscore_needs_saving
    beq.b   1f
    move.l  _dosbase(pc),a6
	bsr.b		get_hiscore_name
    move.l  a0,d1
    move.l  #1006,d2
    jsr     (_LVOOpen,a6)
    move.l  d0,d1
    beq.b   1f
    move.l  d1,d4
    move.l  #SCORE_FILE_SIZE,d3
    move.l  #high_score_buffer,d2
    jsr (_LVOWrite,a6)
    move.l  d4,d1
    jsr (_LVOClose,a6)   
1:	
    rts
    
	
* To get the core to run, you just need to jump to karate_champ_reset after
* you've initialised the platform (Amiga) stuff. That essentially does a
* Z80 reset. You also need to call karate_champ_im1_irq from the Amiga vblank
* routine. They are the only 2 entry points required for the core to run,
* even if there's no other I/O.


demo_game:
		move		#0x4000,_custom+intena						| disable interrupts
		move		#0x7FFF,_custom+intreq						| ack all interrupts
		bsr			platform_init					| amiga-specific init
		*move.l	cheat_flags(pc),d0
		*btst	#0,D0
		*sne		invincible_flag
		*btst	#1,D0
		*sne		infinite_lives_flag
		
0:	

		jmp			karate_champ_reset					| pass control to the pengo core
		

	
				
_vblank:
    movem.l d0-d7/a0-a6,-(a7)
	lea		_custom,a5
	move.w	(intreqr,a5),d0
	btst	#5,d0
	beq.b		1f

	move.l	_joypad_state_p1(pc),d1
	moveq	#1,d0
	jsr	_read_joystick
	move.l	d0,_joypad_state_p1
	
	* CD32 "play" is disabled but it's free to read
	* 3rd button on a Sega 3-button so 3rd button is pause
	btst	#JPB_BTN_PLAY,d0
	beq.b	0f
	btst	#JPB_BTN_PLAY,d1
	bne.b	0f
	bsr		toggle_pause
0:
	* here music doesn't loop. We have to stop it when it ends
	move.w	music_tick(pc),d1
	beq.b	13f
	subq.w	#1,d1
	move.w	d1,music_tick
	bne.b	13f
	bsr		osd_sound_stop
13:

	moveq	#0,d0
	jsr	_read_joystick
	move.l	d0,_joypad_state_p2

	* ack vbl twice (040/pistorm bug)
	move.w	#0x20,(intreq,a5)
	move.w	#0x20,(intreq,a5)	
	bra.b	3f
1:
	* has to be copper
	* we're going to ack copper interrupt now
	* do it twice (040/pistorm bug)
	move.w	#0x10,(intreq,a5)
	move.w	#0x10,(intreq,a5)
	
	moveq	#ONE_TICK,d1
    move.w  vbl_counter(pc),d0
    addq.w  #1,d0
    cmp.w   #5,d0
    bne.b   22f
    * update a second time, simulate 60Hz
	moveq	#ONE_TICK*2,d1
	clr.w d0    
22:
	move.b	d1,vb_ticks_count
    move.w  d0,vbl_counter
	
	tst.b	pause_flag
	bne.b	23f


	jbsr		karate_champ_irq
	.ifne  OPT_ENABLE_DOUBLE_BUFFERING_BG
	bsr		switch_screen_buffers
	.endif
23:
	* now we check copper interrupt again
	move.w	_custom+intreqr,d0
	btst	#4,d0
	beq.b	3f		| clear: ok
	* copper interrupt has been called, which means that
	* rendering was so slow that we couldn't cope within a frame
	* skip a tick and ack again, we lose one update frame
	addq.b	#ONE_TICK,vb_ticks_count
	move.w	#0x10,_custom+intreq
3:
    movem.l (a7)+,d0-d7/a0-a6
    rte
	
osd_break:
	blitz
	rts

*osd_calibrate_display:
*	movem.l	a0/d0-d1,-(a7)
*	move.l	bg_drawed_screen_ptr,a0
*	move.w	#NB_LINES-1,d1
*	clr		d0
*0:
*	st.b	(8,a0,d0.W)
*	st.b	(9,a0,d0.W)
*	st.b	(10,a0,d0.W)
*	
*	add.w	#NB_BYTES_PER_ROW,d0
*	dbf		D1,0b
*	movem.l	(a7)+,a0/d0-d1
*	rts

* < A0: pointer on C700 zone:
*       Sprites
*       -------
*       Offset        Encoding
*            0        YYYYYYYY
*            1        TTTTTTTT
*            2        FGGTCCCC
*            3        XXXXXXXX

	.macro	CONVERT_XY
	add.w	#0x10,d1
	.endm
	
osd_update_sprites:
	*lea		test_sprites_title_xy,a0
	move.l	a0,a6			| save sprite table in A6
	move.w	#NB_TARGET_SPRITES-1,d7
	move.l	previous_sprites_ptr(pc),a4
0:
	moveq	#0,d0
	moveq	#0,d1
	* blit background on each sprite previous position
	move.b	(1,a4),d1
	move.b	(a4),d0
	bne.b	10f
	tst.b	d1
	beq.b	1f
10:
	CONVERT_XY
	lea		bg_screen_backbuffer_data,a0	| source, no sprites, only tiles
	bsr		blit_16x_background
1:
	addq.w	#2,a4
	dbf		d7,0b
	
	move.w	#NB_TARGET_SPRITES-1,d7
	move.l	previous_sprites_ptr(pc),a4
	* for each sprite
0:
	moveq	#0,d0
	moveq	#0,d1
	* sprite Y (amiga X)
	move.b	(a6),d0
	move.b	d0,(a4)+
	* sprite X (amiga Y)
	move.b	(3,a6),d1
	move.b	d1,(a4)+
	tst.b	d0
	jne		10f
	tst.b	d1
	jeq		1f
10:
	.ifne	OPT_ENABLE_LOGGING
	move.l	#sprite_shadow_ram_C700,0x108
	lea		sprite_log_table,a1
	move.l	a1,0x100
	moveq	#0,d2
	move.b	(1,a6),d2
	lsl.w	#8,d2
	move.b	(2,a6),d2
	st.b	(a1,d2.l)
	.endif
	

	* tile index

	moveq	#0,d2
	moveq	#0,d3
	moveq	#0,d4
	moveq	#0,d5
	* tile code
	move.b	(1,a6),d2
	* tile color & attributes
	move.b	(2,a6),d3
	* dispatch the value into several registers
	move.b	d3,d5
	move.b	d3,d4
	move.b	d3,d6
	and.b	#0xF,d4		| color code
	and.b	#0x60,d3
	lsl.w	#4,d3		| sprite bank (0,1,2) * 512
	and.b	#0x10,d5
	lsl.w	#4,d5
	add.w	d5,d2		| extended tile code
	add.w	d3,d2		| add bank offset to tile code
	* now D2 is tile code (0-1535)
	cmp.w	#0x600,d2
	bcc.b	13f

	*     D3 is tile color "table" (0-31)
	lea		sprite_table,a0
	add.w	d2,d2
	add.w	d2,d2
	moveq	#0,d5
	move.l	(a0,d2.w),d5		| offset for color table
	beq.b	12f					| not found
	move.l	d5,a0				| absolute pointer on color table for this sprite
	add.w	d4,d4
	
	move.w	(a0,d4.w),d5		| offset for bitplane list
	beq.b	12f					| not found
	add.w	d5,a0
	* check orientation, add 2 if mirror
	btst	#7,d6
	beq.b	3f
	add.w	(2,a0),a0				| make pointer absolute
	bra.b	4f
3:
	add.w	(a0),a0				| make pointer absolute
4:
	* now A0 is a pointer on a list of 4 16x16 bitplanes + mask
	* get coordinates (D0 is already loaded as X)
	CONVERT_XY
	
	moveq	#0,d2		| no v flip
	move.w	#16,d3		| height = 16

	bsr		blit_16x_bob
1:
	addq.w	#4,a6
	dbf		d7,0b
	rts
12:
	.ifne	OPT_ENABLE_LOGGING
	lsr.l	#2,d2
	lsr.l	#1,d4
	* tile code
	move.l	d2,d0
	* tile color
	move.l	d4,d1
	move.w	#0xF00,0xDFF180
	.endif
	bra.b	1b
13:
	.ifne	OPT_ENABLE_LOGGING
	move.w	#0x0FF,0xDFF180
	.endif
	bra.b	1b



** test sprites for title screen (2 guys fighting)
test_sprites_title_xy:
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xA0
	.byte	0x00,0x00,0x01,0xA0,0x00,0x01,0x01,0xA0,0x00,0x02,0x01,0xA0,0x00,0x00,0x01,0xB0
	.byte	0x00,0x00,0x01,0xB0,0x00,0x03,0x01,0xB0,0x00,0x04,0x01,0xB0,0x00,0x00,0x01,0xC0
	.byte	0x00,0x00,0x01,0xC0,0x00,0x05,0x01,0xC0,0x00,0x06,0x01,0xC0,0x7D,0x26,0x82,0xA0
	.byte	0x8D,0x25,0x82,0xA0,0x9D,0x24,0x82,0xA0,0xAD,0x00,0x82,0xA0,0x7D,0x29,0x82,0xB0
	.byte	0x8D,0x28,0x82,0xB0,0x9D,0x27,0x82,0xB0,0xAD,0x00,0x82,0xB0,0x7D,0x00,0x82,0xC0
	.byte	0x8D,0x2B,0x82,0xC0,0x9D,0x2A,0x82,0xC0,0xAD,0x00,0x82,0xC0,0x42,0x97,0x21,0xA0
	.byte	0x52,0x98,0x21,0xA0,0x62,0x00,0x21,0xA0,0x72,0x00,0x21,0xA0,0x42,0x99,0x21,0xB0
	.byte	0x52,0x9A,0x21,0xB0,0x62,0x9B,0x21,0xB0,0x72,0x00,0x21,0xB0,0x42,0x9C,0x21,0xC0
	.byte	0x52,0x9D,0x21,0xC0,0x62,0x9E,0x21,0xC0,0x72,0x00,0x21,0xC0,0x00,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00

** test for intro screen (2 karatekas, 1 bull)
test_sprites_intro_xy:
	.byte	0x00,0x61,0x41,0x20,0x00,0x62,0x41,0x20,0x00,0x63,0x41,0x30,0x00,0x64,0x41,0x30

    *.byte   0X00,0x61,0x41,0x30,0x00,0x62,0x41,0x30,0x00,0x63,0x41,0x40,0x00,0x64,0x41,0x40
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00


* what: blits 32x16 data on bg plane, no horizontal shifting (erase)
* args:
* < A0: pristine background
* < D0: X (rounded to smaller 8-multiple)
* < D1: Y

* trashes: D0-D1

blit_16x_background:
	movem.l	d2-d6/a0-a5,-(a7)
	lea		_custom,a5
	move.l	bg_drawed_screen_ptr(pc),a1
	* adjust offset X: X//8
	lsr.w	#3,d0
	lea		mulNB_BYTES_PER_ROW_table(pc),a4
	add.w	d1,d1
	* add Y offset: Y*40
	add.w	(a4,d1.w),d0
	* same offset for source and destination
	add.w	d0,a1
	add.w	d0,a0
	
	moveq	#16,d4		| height
    move.l  #0x09f00000,d3    | A->D copy, ascending mode
	moveq	#4,d2			| 32 bits blit
	move.w	#NB_BYTES_PER_ROW,d1		| blit modulo

    sub.w   d2,d1       | blit modulo
    lsl.w   #6,d4
    lsr.w   #1,d2		| blit width
    add.w   d2,d4       | blit height
	
    * always the same settings

    * now just wait for blitter ready to write all registers
	WAIT_BLIT
    
    * blitter registers set

	move.l d3,bltcon0(a5)	| sets con0 and con1

    move.w  d1,bltamod(a5)	|A modulo
    move.w  d1,bltdmod(a5)	|D modulo
							
	move.l a0,bltapt(a5)	|source graphic top left corner
	move.l a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	
	.rept	3
	lea	(BG_SCREEN_PLANE_SIZE,a0),a0
	lea	(BG_SCREEN_PLANE_SIZE,a1),a1
	WAIT_BLIT
	* second bitplane
	move.l a0,bltapt(a5)	|source graphic top left corner
	move.l a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	.endr
	
	movem.l	(a7)+,d2-d6/a0-a5
	rts

* what: blits 16x?? data on bg plane, cookie cut
* args:
* < A0: data (16 pixels wide, 4+1 planes, all planes pointers can be zero,
* if mask is zero then nothing is drawn, as nothing would be drawn anyway!)
* < D0: X
* < D1: Y
* < D2: bit 2: 0: direct, 1: flip
* < D3: height
* trashes: D0-D1

blit_16x_bob:
	tst.l	(NB_PLAYFIELD_PLANES*4,a0)
	bne.b	0f
	rts
0:
	movem.l	d2-d6/a0-a5,-(a7)
	* first check if Y is positive
	moveq	#0,d6	| bitmap offset
	tst		d1
	bpl.b	10f
	* Y is negative, handle the Y-clipping 
	* or completely zap the blit
	add.w	d1,d3
	bmi.b	2f
	beq.b	2f		| no need to blit if height <= 0
	* compute offset to add to bitmap
	neg		d1    | make it positive
	* add a 4-byte offset per line
	move.w	d1,d6
	add.w	d6,d6
	add.w	d6,d6
	moveq	#0,d1	| draw from Y=0
10:
	move.l	bg_drawed_screen_ptr(pc),a1
	lea		blit_planes_cookie_cut_16x(pc),a5
	*btst	#2,d2
	*beq.b	0f
	*lea		blit_planes_cookie_cut_16x_flipped(pc),a5	
*0:
	moveq	#NB_PLAYFIELD_PLANES-1,d5
	moveq	#-1,d2
	move.l	a0,a4		| pointers on planes
	move.l	(NB_PLAYFIELD_PLANES*4,a4),a3		| mask is the last plane
	move.l	a4,a0     | next plane list	
	move.l	a1,a2
	move.w	d6,d2	| y offset for source planes
	jsr		(a5)
2:
	movem.l	(a7)+,d2-d6/a0-a5
	rts
* what: blits 16x16 data on one plane, cookie cut, flip
* args:
* < A0: data (16x16)
* < A1: plane  (40 rows)
* < A2: background (40 rows) to mix with cookie cut
* < A3: source mask for cookie cut (16x16)
* < D0: X
* < D1: Y
* < D2: source y-offset
* < D3: height
* trashes: a lot!
**blit_planes_cookie_cut_16x_flipped:
**    lea _custom,A5
**	move.w	d2,d5
**	move.w	d3,d4
**	neg.w	d4
**	moveq	#4,d3		| 4 planes
**    moveq  #4,d2       | 16 pixels + 2 shift bytes
**    jra blit_planes_any_internal_cookie_cut
* what: blits 16x16 data on one plane, cookie cut
* args:
* < A0: data (16x16)
* < A1: plane  (40 rows)
* < A2: background (40 rows) to mix with cookie cut
* < A3: source mask for cookie cut (16x16)
* < D0: X
* < D1: Y
* < D2: source y-offset
* < D3: height
* trashes: D0-D1
blit_planes_cookie_cut_16x:
    lea _custom,A5
	move.w	d2,d5
	move.w	d3,d4
	moveq	#4,d3		| 4 planes
    moveq  #4,d2       | 16 pixels + 2 shift bytes
* < A5: custom
* < D0.W,D1.W: x,y
* < A0: source (pointer on array of planes)
* < A1: destination fg plane, also background to mix with cookie cut fg plane
* < A3: source mask for cookie cut
* < D2: width in bytes (inc. 2 extra for shifting)
* < D3: number of planes
* < D4: height. If negative, source is copied with negative modulo (flip)
* < D5: y offset for source planes
* < D7: blit mask (not considered, optim, -1 all through the game)
* blit mask set
* returns: start of destination in A1 (computed from old A1+X,Y)
* trashes: a1
blit_planes_any_internal_cookie_cut:
    movem.l d0-d7/a2/a4,-(a7)
    * pre-compute the maximum of shit here
	tst.w	d4
	bpl.b	1f
	sub.w	d4,d1	| pre-add height to d1
	subq.w	#1,d1	| minus one
1:	
	tst	d1
    beq.b   2f    | optim
    lea		mulNB_BYTES_PER_ROW_table,a4
	.ifdef	NO68020
	add.w	d1,d1
    move.w  (a4,d1.w),d1	| y times 40
	.else
    move.w  (a4,d1.w*2),d1	| y times 40
	.endif
2:
	move.w	d5,-(a7)
	moveq	#0,d5
    move.w  #0x0fca,d5    | B+C-A->D cookie cut   
	swap	d5
    move    d0,d6
    beq.b   4f
    lsr.w   #3,d0
	bclr	#0,d0
    and.w   #0xF,d6
	beq.b	3f
    lsl.l   #8,d6
    lsl.l   #4,d6
    or.w    d6,d5            | add shift to mask (bplcon1)
    swap    d6
    clr.w   d6
    or.l    d6,d5            | add shift
3:   
    add.w   d0,d1
4:
    * make offset even. Blitter will ignore odd address
    * but a 68000 CPU doesn't and since we RETURN A1...
    bclr    #0,d1
    add.w   d1,a1       | plane position (D1 < 0x7FFF, 288*40=0x2D00)
	move.w	#NB_BYTES_PER_ROW,d0
	tst.w	d4
	bpl.b	5f
	neg.w	d0
	neg.w	d4    | make d4 positive again
5:
    sub.w   d2,d0       | blit width
    lsl.w   #6,d4
    lsr.w   #1,d2
    add.w   d2,d4       | blit height
    * always the same settings (ATM)

    * now just wait for blitter ready to write all registers
	WAIT_BLIT
    
    * blitter registers set

	clr.w bltamod(a5)		|A modulo=bytes to skip between lines
	clr.w bltbmod(a5)		|B modulo=bytes to skip between lines
	move.l d5,bltcon0(a5)	| sets con0 and con1: full cookie cut 2 sources & 1 mask
	move.l	d5,d7			| save bltcon
	move.w	(a7)+,d5
	
    move.w  d0,bltcmod(a5)	|C modulo
    move.w  d0,bltdmod(a5)	|D modulo
					
	add.w	d5,a3			| apply to mask too
	subq	#1,d3
	beq.b	7f
	subq	#1,d3
6:
	move.l a3,bltapt(a5)	|source graphic top left corner (mask)
	bsr.b	start_process_1_plane
	
	move.l	a1,bltcpt(a5)	|pristine background top (bottom) left corner
	move.l	a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	lea		(BG_SCREEN_PLANE_SIZE,a1),a1
	WAIT_BLIT
	dbf		d3,6b
7:
	move.l a3,bltapt(a5)	|source graphic top left corner (mask)
	bsr.b	start_process_1_plane
	move.l	a1,bltcpt(a5)	|pristine background top (bottom) left corner
	move.l	a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
    
    movem.l (a7)+,d0-d7/a2/a4
    rts
	
start_process_1_plane:
	move.l (a0)+,d0
	beq.b	60f
	move.l	d0,a4
	add.w	d5,a4
	bra.b	61f
60:
	* source is 0: just apply mask (less bandwidth lost) and change bltcon
	move.l	#0x0BCA0000,d3
	or.l	d6,d3
	move.l	d3,bltcon0(a5)	| sets con0 and con1: C-A->D cookie cut, B fixed
 	clr.w	bltbdat(a5)	|B word is zero
	rts
61:
	* non-zero: set data source & bltcon
	move.l	d7,bltcon0(a5)	| sets con0 and con1: C-A+B->D cookie cut full
	move.l	a4,bltbpt(a5)	|source graphic top left corner
	rts
	
* < D0: sprite X
* < D1: sprite Y
* < D2: sprite code & flags
* < D3: sprite color (clut index)
* > D6: allocated sprite index
alloc_sprite:
	* first pass: find a free sprite next to a sprite with
	* same clut
	lea		host_sprites(pc),a2
	moveq	#0,d6
0:
	cmp.b	(SPRITE_CLUT,a2),d3
	bne.b	10f
	* allocated (else would be -1/invalid) + same clut
	* check even/odd index
	btst	#0,d6
	beq.b	1f
	* odd: check if previous entry is free
	tst.b	(SPRITE_X-SPRITE_SIZEOF,a2)
	beq.b	8f
	tst.b	(SPRITE_Y-SPRITE_SIZEOF,a2)
	bne.b	10f
8:
	* previous entry is free, same clut: we can use that
	* entry, no color conflict
	lea		(-SPRITE_SIZEOF,a2),a2
9:
	move.b	d0,(a2)+		| X
	move.b	d1,(a2)+		| Y
	move.b	d2,(a2)+		| code
	move.b	d3,(a2)+		| clut
	rts						| done
1:
	* even: check if next entry is free
	tst.b	(SPRITE_X+SPRITE_SIZEOF,a2)
	beq.b	2f
	tst.b	(SPRITE_Y+SPRITE_SIZEOF,a2)
	bne.b	10f
2:
	* next entry is free, same clut: we can use that
	* entry, no color conflict
	lea		(SPRITE_SIZEOF,a2),a2
	bra.b	9b
10:
	* next entry
	addq.w	#SPRITE_SIZEOF,a2
	addq	#1,d6
	cmp.w	#NB_HOST_SPRITES,d6
	bne.b	0b
	* second pass if first pass failed (could not match
	* a pair with one occupied slot with compatible clut,
	* which happens when there are very few sprites
	* displayed): we have to find 2 consecutive free slots

	lea		host_sprites(pc),a2
	moveq	#0,d6
11:
	* we consider that a sprite is not allocated
	* if one of the coordinates is zero (real game
	* doesn't care and sets X to 255, and Y to 0 at times
	tst.b	(SPRITE_Y,a2)
	beq.b	12f
	tst.b	(SPRITE_X,a2)
	bne.b	20f
12:
	* not allocated: test odd sprite
	tst.b	(SPRITE_Y+SPRITE_SIZEOF,a2)
	jeq	9b
	tst.b	(SPRITE_X+SPRITE_SIZEOF,a2)
	jeq	9b		| ok, both slots are free, allocate the first one
20:
	* next sprite pair
	lea		(2*SPRITE_SIZEOF,a2),a2
	addq	#2,d6
	cmp.w	#NB_HOST_SPRITES,d6
	bne.b	11b
	
	* third pass: last chance/emergency: there ARE free slots
	* (since only 6 sprites on the target) but maybe too many
	* different cluts so we can't find a suitable slot. In that
	* case, pick the first free slot, we'll handle the color changes
	* with a dynamic copperlist, let's hope that it works out
	* (only happens in demo screens)
	*
	* the strategy globally works because during game, all 4 enemies
	* share the same palette. Pengo uses another one, and ice block
	* another one too. Blinking stunned enemies can be a problem
	* because of the extra blue color
	*
	lea		host_sprites(pc),a2
	moveq	#0,d6
21:
	tst.b	(SPRITE_X,a2)
	beq.b	9b		| ok, a slot is free, allocate it
	tst.b	(SPRITE_Y,a2)
	beq.b	9b		| ok, a slot is free, allocate it
30:
	* next sprite
	lea		(SPRITE_SIZEOF,a2),a2
	addq	#1,d6
	cmp.w	#NB_HOST_SPRITES,d6
	bne.b	21b
	* just cannot happen
	* if we reach that point there's a big problem
	blitz
	illegal
	illegal
	illegal
	rts
	

	
osd_sound_enable:	
	rts
osd_sound_disable:	
	rts
osd_sound_start:
	
	movem.l	d0/d1/a0/a6,-(a7)

	and.w	#0xFF,d0


	lea		_custom,a6
	
	
	lsl.w	#3,d0
	lea		sound_table_set_1,a0

	move.w	(a0,d0.w),d1	| sound type
	beq.b	0f		| no sound

2:
	cmp.w	#1,d1
	bne.b	4f		| music module
	move.w	(2,a0,d0.w),d1
	move.l	(4,a0,d0.w),a0
	lea		_custom,a6
	tst.w	d1
	beq.b	3f
	* looped sound
	jsr		_mt_loopfx
	beq.b	1f
3:
	jsr		_mt_playfx
1:
	movem.l	(a7)+,d0/d1/a0/a6
	rts
0:

	bra.b	1b
	* music
4:
	* don't play if game not in play
	* could have been handled at generic pengo.68k level
	* but it's way simpler here. I suppose than the real game
	* just turns music volume off to get away with it
*	tst.b	game_playing_8817
*	beq.b	1b
	
	* don't play if already playing
	* (music_tick value is not important for looped tunes
	* as long as it's not zero)
	tst.w	music_tick
	bne.b	1b
	* play the proper module pattern
	* load up the countdown if loop
	move.w	(2,a0,d0.w),d1	| pattern number in .mod file
	* since it's not zero, next vbl tick will play the music
	cmp.b	music_track_start_number(pc),d1
	beq.b	1b		| same track, skip

    movem.l d0-a6,-(a7)
	bsr		osd_sound_stop
    lea _custom,a6
 	movem.l	d0/a0,-(a7)
    lea	karate_champ_tunes,a0
	move.b	d1,music_track_start_number
	move.w	d1,d0
    sub.l   a1,a1		| samples are in the module
    jsr _mt_init
	movem.l	(a7)+,d0/a0

    * set master volume a little less loud if needed
	move.b	(6,a0,d0.w),music_volume
	move.b	(7,a0,d0.w),music_loops
	move.w	(2,a0,d0.w),music_pattern	| pattern number in .mod file
	move.w	(4,a0,d0.w),d2
	move.w	d2,music_duration
	move.w	d2,music_tick

    moveq	#0,d0
	move.b	music_volume(pc),d0
    jsr	_mt_mastervol
	st.b	music_playing
    jsr _mt_start
    movem.l (a7)+,d0-a6
	
6:
	jra	1b

7:
	jra	1b
	tst.b	music_playing
	jeq	1b
	bsr		osd_sound_stop
	jra	1b
	

osd_sound_stop:
	movem.l	d0/a0/a6,-(a7)
	lea		_custom,a6
	move.b	#-1,music_track_start_number
    clr.w   music_tick   | not playing anymore
	clr.b	music_playing
    jsr		_mt_end
0:
	movem.l	(a7)+,d0/a0/a6
	rts
	


switch_screen_buffers:
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING_BG
	* let's switch screen buffers, background (chars)
	* toggle fg planes (double buffering)
	lea		bg_drawed_screen_ptr(pc),a0
	lea		bg_displayed_screen_ptr(pc),a4
	lea		previous_sprites_ptr(pc),a6
	lea		bg_screen_data_1,a1
	lea		bg_screen_data_2,a5
	lea		previous_sprites_1,a2
	lea		previous_sprites_2,a3
	* also switch previous state memory
	cmp.l	(a0),a1
	bne.b	2f
	* screen data 1 is displayed screen
	* set it to drawn screen
	exg		a1,a5
	exg		a2,a3
2:
	move.l	a1,(a0)
	move.l	a5,(a4)
	move.l	a3,(a6)
	jbsr		set_bg_bitplanes
	.endif
	
	rts

	
store_system:
	tst.l	_resload
	beq.b	0f
	rts
0:
	* system copper
	
	move.l	4.W,a6
	move.w	AttnFlags(a6),d0
	btst	#AFB_68010,d0
	beq.b	1f
	lea	get_vbr,a5
	jsr		_LVOSupervisor(a6)
	move.l	d0,system_vbr
1:
	
	lea	_custom,a6
	move.w	intenar(a6),old_intena
	move.w	dmaconr(a6),old_dmacon
	lea		old_sysvectors,a0
	move.l	system_vbr(pc),a1
	move.l	(0x8,a1),(a0)+
	move.l	(0xC,a1),(a0)+
	move.l	(0x10,a1),(a0)+
	move.l	(0x14,a1),(a0)+
	move.l	(0x28,a1),(a0)+
	move.l	(0x2C,a1),(a0)+
	move.l	(0x30,a1),(a0)+
	move.l	(0x64,a1),(a0)+
	move.l	(0x68,a1),(a0)+
	move.l	(0x6c,a1),(a0)+
	move.l	(0x70,a1),(a0)+
	move.l	(0x74,a1),(a0)+
	move.l	(0x78,a1),(a0)+
	
	lea		trap_handlers(pc),a0
	* install trap handlers
	move.l	(a0)+,(0x8,a1)
	move.l	(a0)+,(0xC,a1)
	move.l	(a0)+,(0x10,a1)
	move.l	(a0)+,(0x14,a1)
	move.l	(a0)+,(0x28,a1)
	move.l	(a0)+,(0x2C,a1)
	move.l	(a0)+,(0x30,a1)
	rts

trap_handlers:
	.long	exc_handler_08
	.long	exc_handler_0C
	.long	exc_handler_10
	.long	exc_handler_14
	.long	exc_handler_28
	.long	exc_handler_2C
	.long	exc_handler_30


exc_handler_08:
	move	#8,d7
	bra.b	exc_loop
exc_handler_0C:
	move	#12,d7
	bra.b	exc_loop
exc_handler_10:
	move	#0x10,d7
	bra.b	exc_loop
exc_handler_14:
	move	#0X14,d7
	bra.b	exc_loop
exc_handler_28:
	move	#0X28,d7
	bra.b	exc_loop
exc_handler_2C:
	move	#0x2C,d7
	bra.b	exc_loop
exc_handler_30:
	move	#0x30,d7
exc_loop:
	move.w	d7,0x60.W
	move.w	#0x2700,SR
	move.w	#0xF0F,_custom+color
	bra.b	exc_loop





restore_system:
	lea	_custom,a6
	jsr		_mt_remove_cia

	move.w	#0x4000,intena(a6)	| ints off
	lea		old_sysvectors,a0
	move.l	system_vbr(pc),a1
	move.l	(a0)+,(0x8,a1)
	move.l	(a0)+,(0xC,a1)
	move.l	(a0)+,(0x10,a1)
	move.l	(a0)+,(0x14,a1)
	move.l	(a0)+,(0x28,a1)
	move.l	(a0)+,(0x2C,a1)
	move.l	(a0)+,(0x30,a1)
	move.l	(a0)+,(0x0064,a1)
	move.l	(a0)+,(0x0068,a1)
	move.l	(a0)+,(0x006c,a1)
	move.l	(a0)+,(0x0070,a1)
	move.l	(a0)+,(0x0074,a1)
	move.l	(a0)+,(0x0078,a1)


	bclr	#6,0xbfee01


	lea	_custom,a6
	move.w	old_intena,d0			| get old val
	and.w	#0x3fff,d0
	eor.w	#0x3fff,d0
	move.w	d0,intena(a6)		| clr bits
	eor.w	#0x3fff,d0
	or.w	#0xc000,d0		
	move.w	d0,intena(a6)		| set bits and main

	move.w	old_dmacon,d0			| get old val
	and.w	#0x3fff,d0
	eor.w	#0x3fff,d0

***		and.w	#0xfff0,d0		| preserve sound dma for now

	move.w	d0,dmacon(a6)		| clr bits



	eor.w	#0x3fff,d0
	or.w	#0xc000,d0		
	move.w	d0,dmacon(a6)		| set bits and main

	move.l	old_syscoplist,cop1lc(a6)
	move.l	_gfxbase,a6
	move.l	old_actiview,a1
	jsr	_LVOLoadView(a6)


	moveq	#0,d0
	rts

quit_to_os:
	bsr		restore_system
	move.w	#0,SR
	move.l	old_stack(pc),a7
	bsr		save_highscores
	moveq	#0,d0
	rts
	

platform_init:
	bsr		store_system
	
	lea		_custom,a5
	move.w	#0x7FFF,dmacon(a5)
	move.w	#0x7FFF,intena(a5)
	* set blitter parameters once and for all
	.ifndef	VARIABLE_BLITTER_MASKS_AND_MODS
    move.l  #-1,bltafwm(a5)
	.endif
	
	* restrict borders: we don't see bobs on the borders!
    move.w #0x1C99,diwstrt(a5)
    move.w #0x3881-8,diwstop(a5)
    move.w #0x0038,ddfstrt(a5)
    move.w #0x00D0,ddfstop(a5)
    move.w #0x4200,bplcon0(a5) | 4 bitplanes
    move.w #0x0024,bplcon2(a5)
	* AGA-compatible ECS default values
    move.w #0x0C00,bplcon3(a5)     | no AGA specificities, default ECS
    move.w #0x0011,bplcon4(a5)     | ECS default for sprite colors
    move.w #0,fmode(a5)			
	

    move.w #0,bplcon1(a5)    | foreground tiles
	move.w	#0,d0
    move.w d0,bpl1mod(a5)
    move.w d0,bpl2mod(a5)
	move.w d0,bltamod(a5)		|A modulo=bytes to skip between lines
	move.w d0,bltbmod(a5)		|B modulo=bytes to skip between lines
    move.l  #-1,bltafwm(a5)	| no mask on first & last word

	* set other sprites to blank
	move.l		#blank_sprite,d0

	moveq	#7,d1
	lea		sprites,a1
0:
    move.w	d0,(6,a1)
	swap	d0
    move.w	d0,(2,a1)
	swap	d0
	addq.w	#8,a1
	dbf		d1,0b
	
	bsr		set_bg_bitplanes
	lea		palette(pc),a0		| base palette
	bsr		load_palette_in_copperlist
	
	* set copperlist
	move.l	#copperlist,cop1lc(a5)

	* wait 300 lines
	move.w	#100,d0
	bsr	beamdelay
	move.w	#100,d0
	bsr	beamdelay
	move.w	#100,d0
	bsr	beamdelay
	
    * init sprite, bitplane, whatever dma

    move.w #0x83E0,dmacon(a5)
    *move.w #0x20,dmacon(a5)

	* install keyboard and vblank/copper handler
	pea		level2_interrupt(pc)
	move.l	system_vbr(pc),a1
	move.l	(a7)+,(0x68,a1)
	pea		_vblank(pc)
	move.l	(a7)+,(0x6C,a1)

	* soundfx lib
	lea		_custom,a6
	lea		blank_sound,a0
	move.l	a0,(0xA0,a6)
	move.l	a0,(0xB0,a6)
	move.l	a0,(0xC0,a6)
	move.l	a0,(0xD0,a6)
	move.l	system_vbr(pc),a0
	moveq	#1,d0	| PAL
	jsr		_mt_install_cia

	.ifne	OPT_ENABLE_PROFILING
	* init profiling if enabled
	lea		0x180000,a0
	move.l	#0x20000,d0
	lea		0x100,a1
	bsr		init_fixed_address
	bsr		install_profiler_vbl_hook
	.endif

	
    rts

	
load_palette_in_copperlist:
	movem.l	d0-d1/a0-a1,-(a7)
	move.w	#TOTAL_NB_COLORS-1,d0
	lea		copperlist_colors+2,a1
1:
	move.w	(a0)+,(a1)+
	addq.w	#2,a1
	dbf		d0,1b
	movem.l	(a7)+,d0-d1/a0-a1
	rts
	

* 60Hz VBLANK interrupt (also keyboard)
osd_enable_vblank_interrupt:
	move.w	#0xC038,_custom+intena
	rts

osd_ack_vblank_interrupt:
	move.w	#0x30,_custom+intreq
 	rts
		
* not used after all
*osd_test_vblank_interrupt:
*	move.w	_custom+intreqr,d0
*	btst	#5,d0
*	rts
	
osd_disable_vblank_interrupt:
	move.w	#0x0030,_custom+intena
	rts




	
	
* < D4: sprite properties
*     Y code+attrs clut X
* > D0,D1: X,Y.B
* > D5: clut index
* > D6: sprite index + attributes
* 
decode_sprite_data:
	move.b	d4,d1	| sprite X (aka Y on amiga)
	lsr.l	#8,d4
	move.b	d4,d5	| clut index
	lsr.l	#8,d4
	move.b	d4,d6	| sprite index
	lsr.l	#8,d4	
	move.b	d4,d0	| sprite Y (aka X on amiga)
	rts

* d6=screen address
osd_r_videoram:
	movem.l	a0/d6,-(a7)
	sub.w	#SCREEN_ADDRESS,d6
	cmp.w	#0x400,d6
	bcs.b	1f
	* should not happen
	move.w	#0,d6
1:
	lea		bg_videoram,a0
	move.b	(a0,d6.w),d0
	movem.l	(a7)+,a0/d6
	rts
* d6=screen address
osd_r_colorram:
	movem.l	a0/d6,-(a7)
	sub.w	#SCREEN_ADDRESS+0x400,d6
	cmp.w	#0x400,d6
	bcs.b	1f
	* should not happen
	move.w	#0,d6
1:	
	lea		bg_colorram,a0
	move.b	(a0,d6.w),d0
	movem.l	(a7)+,a0/d6
	rts
	
* d6=screen address (preserved), d0=tile (preserved)
* d6 starts at 0xD000 ends at 0xD3FF
* should preserve all registers

osd_w_videoram:
     .ifeq OPT_DISABLE_BG_LAYER
	movem.l	d0-d3/d6/a0-a3,-(a7)
	
	sub.w	#SCREEN_ADDRESS,d6
	cmp.w	#0x400,d6
	bcs.b	1f
	* should not happen
	move.w	#0,d6
1:
	lea		bg_videoram,a1
	add.w	d6,a1
	

	cmp.b	(a1),d0
	beq.b	0f		| already the proper value

	move.b	d0,(a1)	| update logical grid
	lea		bg_colorram,a1
	move.b	(a1,d6.W),d1
	jbsr		update_bg_tile
0:
	movem.l	(a7)+,d0-d3/d6/a0-a3
    .endif | OPT_DISABLE_BG_LAYER
	rts

* d6=screen address (preserved), d0=attribute (preserved)
* d6 starts at 0xD400 ends at 0xD7FF
* should preserve all registers

osd_w_colorram:
   .ifeq OPT_DISABLE_BG_LAYER
	movem.l	d0-d3/d6/a0-a3,-(a7)
	sub.w	#SCREEN_ADDRESS+0x400,d6
	cmp.w	#0x400,d6
	bcs.b	1f
	* should not happen
	move.w	#0,d6
1:
	lea		bg_colorram,a1
	add.w	d6,a1
	cmp.b	(a1),d0
	beq.b	0f		| already the proper value
	
	move.b	d0,(a1)	| update logical grid
	move.b	d0,d1
	lea		bg_videoram,a1
	move.b	(a1,d6.W),d0
	
	jbsr		update_bg_tile
0:
	movem.l	(a7)+,d0-d3/d6/a0-a3
    .endif | OPT_DISABLE_BG_LAYER
	rts


* d6: screen offset
* d0: tile code
* d1: attribute
*
* the layout is strange to say the least
* first row (last row in memory) is shown "normally" (X is mirrored, but horizontal,
* Y is at top of the screen)
* other rows use a X/Y transposed system like Galaxian or Xevious!
*
update_bg_tile:
	* get current level
	moveq	#0,d2
	* not working!!

	move.b	#0,0x200
	move.w	level_pointer_C902,d2
	cmp.w	current_background,d2
	beq.b	1f
	move.w	d2,current_background

	ror.w	#8,d2		| swap endianness
	sub.l	#0x534d,d2	| pointer on level 1
	bne.b	12f
	* bamboo practice: same as level 3
	move.w	#2,d2
	bra.b	10f
12:
	divu	#5,d2
	cmp.w	#24,d2		| not a level if >= 24
	bcs.b	0f
	* default palette (title, menu...)
	moveq	#0,d2
	bra.b	11f
0:
	cmp.w	#12,d2
	bcs.b	10f
	sub.w	#12,d2		| same background, subtract 12
10:
	addq.w	#1,d2		| level palettes start at 1
	lsl.w	#5,d2		| times 32 to select proper palette
11:
	lea		palette(pc),a0
	add.w	d2,a0
	bsr		load_palette_in_copperlist
1:	
	* compute Y
	and.w	#0xFF,d0	| mask up to 255
	and.w	#0xFF,d1	| mask up to 255

	.ifne	OPT_ENABLE_LOGGING
	* when logging is enabled, play a while
	* and break. Get the address in 0x100 then do
	* S used_cluts <address at $100> $10000
	* then run the compute_used_cluts.py program again
	
	lea		tile_log_table,a0
	move.l	a0,0x104  | DEBUG
	movem.l	d0-d1,-(a7)
	and.l	#0xFFFF,d0
	lsl.w	#8,d0
	add.b	d1,d0
	st.b	(a0,d0.l)
	movem.l	(a7)+,d0-d1
	.endif

	* color code first 3 bits are actually tile code high bits (8-11)
	* color code needs 3 bit right shift & mask

	move.b	d1,d2
	and.b	#7,d2
	lsl.w	#8,d2
	add.w	d2,d0		| extended character code
	lsr.b	#3,d1
	and.b	#0x1F,d1	| proper color code

	move.w	d6,d3
	lsr.w	#5,d6		| this is X
	neg.w	d6
	add.w	#32,d6
	and.w	#0x1F,d3	| this is Y
	addq.w	#2,d3

	lea		mulNB_BYTES_PER_ROW_table(pc),a0

	
	move.l	bg_drawed_screen_ptr(pc),a1
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING_BG
	move.l	bg_displayed_screen_ptr(pc),a4
	.endif
	* D3 = Y

	add.w	d3,d3
	move.w	(a0,d3.w),d3
	lsl.w	#3,d3		| times 8
	add.w	d6,d3		| global offset
	add.w	d3,a1
	lea		bg_screen_backbuffer_data,a2
	add.w	d3,a2
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING_BG
	add.w	d3,a4
	.endif

	moveq	#NB_PLAYFIELD_PLANES-1,d3

	* optimization when a well-known
	* empty character is passed (standard charset)
	**cmp.w	#0x20,d0	| empty character
	**jeq	1f
	
	lea		character_table,a0
	add.w	d0,d0
	add.w	d0,d0
	move.l	(a0,d0.w),d0
	jeq	1f
	move.l	d0,a0		| pointer on clut table
	* now we use d1 (attribute) to get byte displacement on relative pointer
	* (this sounds complex but allows to save 60k+ memory vs the direct word
	* relative pointer previous solution. Access to tiles is less time critical
	* so it's acceptable)
	and.w	#0x1F,d1
	move.b	(a0,d1.w),d1
	add.w	d1,a0
	cmp.l	d0,a0
	jeq		12f		| should not happen
	move.w	#BG_SCREEN_PLANE_SIZE,d1
	* compute absolute pointer on bitmap data
	add.w	(a0),a0
4:
	.set	offset,0
	.rept	8
	move.b	(a0)+,d0
	move.b	d0,(offset,a1)	
	move.b	d0,(offset,a2)
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING_BG
	move.b	d0,(offset,a4)
	.endif	
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	add.w	d1,a1
	add.w	d1,a2
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING_BG
	add.w	d1,a4
	.endif
	dbf		d3,4b
0:
	rts

1:
	move.w	#BG_SCREEN_PLANE_SIZE,d0
11:
	.set	offset,0
	.rept	8
	clr.b	(offset,a1)
	clr.b	(offset,a2)
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING_BG
	clr.b	(offset,a4)
	.endif	
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	add.w	d0,a1
	add.w	d0,a2
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING_BG
	add.w	d0,a4
	.endif
	dbf		d3,11b
2:
	rts

12:
	* clut/tile combo not declared as used
	**blitz
	rts


			
store_sprite_pos_16:
	move.l	a1,-(a7)
	lea		HW_SpriteYTable_16,a1
	bsr		store_sprite_pos
	move.l	(a7)+,a1
	rts
	
* < d0.w: x
* < d1.w: y
* < a1: sprite pos table (depending on height)
* > d0.L: control word
store_sprite_pos:
    move.l  a0,-(a7)

    lea	HW_SpriteXTable(pc),a0
	
	.ifdef	NO68020
    add.w	d0,d0
    add.w	d0,d0
    move.l	(a0,d0.w),d0
	move.w	d1,-(a7)
    add.w	d1,d1
    add.w	d1,d1
    or.l	(a1,d1.w),d0
	move.w	(a7)+,d1
	.else
    move.l	(a0,d0.w*4),d0
    or.l	(a1,d1.w*4),d0	
	.endc
    move.l  (a7)+,a0
    rts
	
HW_SpriteXTable:
	.set	reptn,0
	.rept 320
	.set	x,reptn+0x80
	.set reptn,reptn+1
    .byte  0,x>>1,0,x&1
  .endr

	.macro DEF_HW_SPRITE_Y_TABLE	height
HW_SpriteYTable_\height:
  .set	reptn,0
  .rept 288
	.set	ys,reptn+0x1c
	.set	ye,ys+\height
    .byte  ys&255, 0, ye&255, ((ys>>6)&4)+((ye>>7)&2)
	.set	reptn,reptn+1
  .endr
	.endm

	DEF_HW_SPRITE_Y_TABLE	0
	DEF_HW_SPRITE_Y_TABLE	8
	DEF_HW_SPRITE_Y_TABLE	16
	DEF_HW_SPRITE_Y_TABLE	32



	
* set_bitplanes
* what: sets bitplanes in copperlist

set_bg_bitplanes:
    move.l	bg_displayed_screen_ptr(pc),a0
    moveq #NB_PLAYFIELD_PLANES-1,d1
	move.l	a0,d0
    lea	bg_bitplanes+2,a0
1:
    swap d0
    move.w d0,(a0)
    swap d0
    move.w d0,(4,a0)    
    addq.w  #8,a0
    add.l #BG_SCREEN_PLANE_SIZE,d0
    dbf d1,1b
    rts

	

osd_debug_hook:
	rts
	
	
osd_read_dipswitches:
	move.b	dip_switches(pc),d0
	rts
	
* reads most inputs in one call
* bits 
osd_read_inputs:
	bsr		handle_keyboard
	moveq	#-1,d0
	movem.l	a0/d1,-(a7)
	* misc control keys
	lea		keyboard_table(pc),a0
	tst.b	(5,a0)		| "5" key like in MAME
	beq.b	0f
	bclr	#16,d0
0:
	tst.b	(6,a0)		| "6" key like in MAME
	beq.b	0f
	bclr	#1+16,d0
0:	
	tst.b	(1,a0)		| "1" key like in MAME
	beq.b	0f
	bclr	#2+16,d0
0:
	tst.b	(2,a0)		| "2" key like in MAME
	beq.b	0f
	bclr	#3+16,d0
0:
	move.l	_joypad_state_p2(pc),d1
	jbsr		check_joy
	lsl.w	#8,d0
	st		d0
	move.l	_joypad_state_p1(pc),d1
	jbsr		check_joy
	
	movem.l	(a7)+,a0/d1
	rts


	.ifdef	ZZZZZ
	tst.b	(0x4F,a0)		| "<-" key
	beq.b	0f
	bclr	#26,d0
0:
	tst.b	(0x4E,a0)		| "->" key
	beq.b	0f
	bclr	#27,d0
0:
	tst.b	(0x4C,a0)		| "up" key
	beq.b	0f
	bclr	#24,d0
0:
	tst.b	(0x4D,a0)		| "down" key
	beq.b	0f
	bclr	#25,d0
0:
	tst.b	(0x63,a0)		| "ctrl" key
	beq.b	0f
	bclr	#31,d0
0:
	* directions + fire
	move.l	_joypad_state(pc),d1
	btst	#JPB_BTN_UP,d1
	beq.b	0f
	bclr	#24,d0
0:
	btst	#JPB_BTN_DOWN,d1
	beq.b	0f
	bclr	#25,d0
0:
	btst	#JPB_BTN_LEFT,d1
	beq.b	0f
	bclr	#26,d0
0:
	btst	#JPB_BTN_RIGHT,d1
	beq.b	0f
	bclr	#27,d0
0:
	btst	#JPB_BTN_RED,d1
	beq.b	0f
	bclr	#31,d0
0:
	*tst.b	game_playing_8817
	*bne.b	3f
	move.l	d2,-(a7)
	move.l	_previous_joypad_state(pc),d2
	* save prev state as game loops within vblank
	* pushing fire would either lockup the game
	* or insert a lot of credits simulatenously
	move.l	_joypad_state,_previous_joypad_state
	
	* game not in play, accept start 1P game with "up"
	btst	#JPB_BTN_UP,d1
	beq.b	0f
	bclr	#5+16,d0
0:
	* game not in play, accept start 2P game with "down"
	btst	#JPB_BTN_DOWN,d1
	beq.b	0f
	bclr	#6+16,d0
0:
	btst	#JPB_BTN_RED,d1
	beq.b	0f
	btst	#JPB_BTN_RED,d2
	bne.b	0f
	* game not in play, accept insert coin with fire
	bclr	#6,d0
0:
	move.l	(a7)+,d2
3:
	.endif
	
	movem.l	(a7)+,a0/d1
	rts
	

check_joy:
	btst	#JPB_BTN_RIGHT,d1
	beq.b	0f
	bclr	#0,d0
0:
	btst	#JPB_BTN_LEFT,d1
	beq.b	0f
	bclr	#1,d0
0:
	btst	#JPB_BTN_UP,d1
	beq.b	0f
	bclr	#2,d0
0:
	btst	#JPB_BTN_DOWN,d1
	beq.b	0f
	bclr	#3,d0
0:
	btst	#JPB_BTN_YEL,d1		| left
	beq.b	0f
	bclr	#4,d0
0:
	btst	#JPB_BTN_RED,d1		| right
	beq.b	0f
	bclr	#5,d0
0:
	btst	#JPB_BTN_BLU,d1		| up
	beq.b	0f
	bclr	#6,d0
0:
	btst	#JPB_BTN_GRN,d1		| down
	beq.b	0f
	bclr	#7,d0
0:
	rts
		
osd_read_high_scores:
	movem.l	d0-d7/a0-a6,-(a7)
	move.l	a0,a4
	move.l	_resload(pc),d0
	beq.b	0f
	move.l	d0,a2
	move.l	a0,a3
	bsr		get_hiscore_name
 	jsr		resload_GetFileSize(a2)		
	tst.l	d0
	beq.b	1f
	bsr		get_hiscore_name
	move.l	a3,a1
	jsr		resload_LoadFile(a2)
	* set highest score entry
    move.b    (a3)+,(a4)+
    move.b    (a3)+,(a4)+
    move.b    (a3)+,(a4)+		
	bra.b	1f
0:
	tst.b	highscore_loaded
	beq.b	1f
	* from DOS: just copy buffer
	lea		high_score_buffer(pc),a1
	* set highest score entry
	move.w	#SCORE_FILE_SIZE-1,d0
0:
    move.b    (a1)+,(a4)+
	dbf		d0,0b
1:
	movem.l	(a7)+,d0-d7/a0-a6
	rts
	
osd_write_high_scores:
	movem.l	d0-d7/a0-a6,-(a7)
	tst.b	cheat_used		| don't save score if cheat on
	bne.b	1f
	move.l	_resload(pc),d0
	beq.b	0f
	move.l	d0,a2
	move.l	#SCORE_FILE_SIZE,d0
	move.l	a0,a1
	bsr		get_hiscore_name
	jsr		resload_SaveFile(a2)
	bra.b	1f
0:
	* from DOS: just copy buffer
	lea		high_score_buffer(pc),a1
	move.w	#SCORE_FILE_SIZE-1,d0
0:
	move.b	(a0)+,(a1)+
	dbf		d0,0b

	st.b	highscore_needs_saving
1:
	movem.l	(a7)+,d0-d7/a0-a6
	rts


level2_interrupt:
	bsr		handle_keyboard
	move.w	#8,_custom+intreq
	rte
	
handle_keyboard:
	movem.l	D0/A0/A5,-(a7)
	LEA	0x00BFD000,A5
	MOVEQ	#0x08,D0
	AND.B	0x1D01(A5),D0
	jeq		1f
	MOVE.B	0x1C01(A5),D0
	NOT.B	D0
	ROR.B	#1,D0		| raw key code here
  
	CLR.B	0x1C01(A5)
  
    lea keyboard_table(pc),a0
	
    bclr    #7,d0
    seq (a0,d0.w)       | updates keyboard table
    bne.b   0f     | we don't care about key release
    
    cmp.b   #0x19,d0	| "P" key
    bne.b   0f

    bsr	toggle_pause
0:
	.ifdef RELEASE
	btst	#2,cheat_flags+3
	beq.b	0f
	.endif
	* cheat keys
	cmp.b	#0x50,d0	| F1 key
	bne.b	0f
	st.b	cheat_used
	* next hit (even in the air), P1 wins round
	move.w	#0x101,player_1_points_C91A
	st.b	fake_p1_hit_flag
	* faster countdown
	move.b	#2,match_timer_C167
	move.w	#0xFFF,_custom+color
0:
	cmp.b	#0x51,d0	| F2 key
	bne.b	0f
	* next hit (even in the air), P2 wins round
	st.b	cheat_used
	move.w	#0x101,player_2_points_C91C
	st.b	fake_p2_hit_flag
	move.b	#2,match_timer_C167
	move.w	#0xF00,_custom+color
0:
	cmp.b	#0x52,d0	| F3 key
	bne.b	0f
	st.b	cheat_used
*	st.b	snobee_chicken_flag
0:
	.ifndef	RELEASE
	cmp.b	#0x58,d0	| F9 key
	bne.b	0f
	illegal
	.endif
0:
	tst.l	_resload
	bne.b	0f
	cmp.b	#0x45,d0	| "ESC" key
	bne.b	0f
	BSET	#0x06,0x1E01(A5)
	moveq	#2,d0
	bsr	beamdelay
	BCLR	#0x06,0x1E01(A5)	| acknowledge key
	bra		quit_to_os
0:
	BSET	#0x06,0x1E01(A5)
	moveq	#2,d0
	bsr	beamdelay
	BCLR	#0x06,0x1E01(A5)	| acknowledge key

1:
	movem.l	(a7)+,d0/a0/a5
	rts
	
toggle_pause:
	* pause only within game
	*tst.b	game_playing_8817
	*beq.b	0f
	eor.b   #1,pause_flag
0:
	rts
	
    
* < D0: numbers of vertical positions to wait
beamdelay:
0:
	move.w  d0,-(a7)
    move.b	0xdff006,d0	| VPOS
1:
	cmp.b	0xdff006,d0
	beq.s	1b
	move.w	(a7)+,d0
	dbf	d0,0b
	rts

	
	MUL_TABLE	NB_BYTES_PER_ROW,288

	.align	4		| leave this long word alignment
program_args:	ds.l	64,0
program_args_end:
	.long	0		| add a longword else it overwrites the read args string in kick 1.3!
	.align	4
read_args_string:
	.byte	read_args_string_end-read_args_string
	.ascii	"INVINCIBLE/S,INFLIVES/S,CHEATKEYS/S,STARTLEVEL/K/N,"
	.ascii	"BAT50000/S,QUICKMAZEDRAW/S,NOINTERMISSIONS/S,ALTMUSIC/S"
	.ascii	",SKILL/K/N"
read_args_string_end:
	.align	2


* 8 slots (indexed with the target sprite index, not
* the amiga sprite index) with
* - 4 bytes for the sprite actual address
* - 2 bytes amiga sprite index
* - 2 bytes??
hw_sprite_slots:
	ds.b	8*8
* 8 slots (indexed with the amiga sprite index)
amiga_sprite_slots:
	ds.b	8

old_intena:
	.long	0
old_dmacon:
	.long	0
old_sysvectors:
	ds.l	16
old_vbr:
	.long	0
old_syscoplist:
	.long	0
old_actiview:
	.long	0
old_stack:
	.long	0

	
	
_tag:
		.long	WHDLTAG_CUSTOM1_GET
cheat_flags:
		.long	0
		.long	WHDLTAG_CUSTOM3_GET
start_level_option:
		.long	0
		.long	WHDLTAG_CUSTOM4_GET
misc_options:
		.long	0
		.long	WHDLTAG_CUSTOM2_GET
dip_switch_difficulty:
		.long	0
		.long	0
	.long	0
dip_switches:
		.word	0

system_vbr:
	.long	0
	
orig_color_4:
	.word	0
	
high_score_buffer:
	ds.b	SCORE_FILE_SIZE

highscore_needs_saving:
	.byte	0
highscore_loaded:
	.byte	0
flip_flop:
	.byte	0
	.align	2

host_sprites:
	ds.b	8*SPRITE_SIZEOF
keyboard_table:
	ds.b	0x100


previous_sprites_ptr:
	dc.l	previous_sprites_1
previous_sprites_1:
	ds.w	NB_TARGET_SPRITES
previous_sprites_2:
	ds.w	NB_TARGET_SPRITES
	
pause_flag:
	dc.w	0

	* sound variables
music_duration:
	.word	0
music_track_start_number:
	.word	0
music_pattern:
	.word	0
music_tick:
	.word	0
intro_music_counter:
	.word	0
vbl_counter:
	.word	0
_resload:
	.long	0
_joypad_state_p1:
	.long	0
_previous_joypad_state_p1:
	.long	0
_joypad_state_p2:
	.long	0
_previous_joypad_state_p2:
	.long	0
_gfxbase:
	.long	0
_dosbase:
	.long	0
bg_drawed_screen_ptr:
	.long	bg_screen_data_1
bg_displayed_screen_ptr:
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING_BG
	.long	bg_screen_data_2
	.else
	.long	bg_screen_data_1
	.endif
current_background:
	.word	0xFF


	.include	"sound_entries.68k"

alternate_bank_selectors:
	.byte	0
first_row_standard_bank_selector:
	.byte	0
music_loops:
	.byte	0
music_volume:
	.byte	0
music_playing:
	.byte	0
music_muted:
	.byte	0
cheat_used:
	.byte	0
dosname:
	.ascii	"dos.library"
	.byte	0
graphicsname:
	.ascii	"graphics.library"
	.byte	0
normal_hiscorename:
	.asciz	"kchamp.high"
floppy_file:
	.ascii	"floppy"
	.byte	0
temp_filename_buffer:
	ds.b	255
_end_of_ng_code:
		
	.align 2
palette:
	.include "palette.68k"


	
	
	* on amiga, this file is included in karate_champ.68k file
	* so the assembler can optimize by using PC-relative addressing
	* whenever possible (and it does)
	.ifndef	RELEASE
	* easier to debug game to have memory aligned on 0x10000
	.ifeq	OPT_ENABLE_LOGGING
	.align	0x10000

	.else  |	OPT_ENABLE_LOGGING
	.section	.bss
tile_log_table:
	* a lot of combinations aren't used (fortunately!)
	ds.b	0x10000
sprite_log_table:
	* a lot of combinations aren't used (fortunately!)
	ds.b	0x10000
	.endif
	.endif


	.section	.datachip
	
.macro	DECL_4_BITPLANES	bpoff_start
	.set	bpoff,\bpoff_start
	.rept	NB_PLAYFIELD_PLANES
	dc.w  0xe0+bpoff,0
	dc.w  0xe2+bpoff,0
	.set	bpoff,bpoff+4
	.endr
	.endm

.macro	DECL_16_COLORS	offset
	.set	colidx,\offset
	.rept	16
	dc.w	color+(colidx*2),0
	.set	colidx,colidx+1
	.endr
	.endm

blank_sound:
	ds.l	4
	
debug_copperlist:
	dc.w	color
debug_color:
	dc.w	0
	dc.l	-2
	
blank_sprite:
	.rept	32
	.long	0
	.endr
	
	
	* main copperlist
copperlist:
    *.word   0x1801,0xFFFE	

bg_bitplanes:
	DECL_4_BITPLANES	0
copperlist_colors:
	DECL_16_COLORS	0
sprite_cols:
	DECL_16_COLORS	16
sprites:
    * #0
    .word    sprpt+0,0
    .word    sprpt+2,0
    * #1
    .word    sprpt+4,0
    .word    sprpt+6,0
    * #2
    .word    sprpt+8,0
    .word    sprpt+10,0
    * #3
    .word    sprpt+12,0
    .word    sprpt+14,0   
    * #4
    .word    sprpt+16,0
    .word    sprpt+18,0
    * #5
    .word    sprpt+20,0
    .word    sprpt+22,0
    * #6
    .word    sprpt+24,0
    .word    sprpt+26,0
    * #7
    .word    sprpt+28,0
    .word    sprpt+30,0

	.set    beampos,0x1C01
color_line_copper:
	.word	beampos,0xFFFE
	*.set    beampos,beampos+0x100


	* pal limit
    .word  0xFFDF,0xFFFE       | PAL wait
    .word  0x0401,0xFFFE

	.set    beampos,0x0401
    .word   beampos,0xFFFE	
	
color_row_29:
	
	.set    beampos,0x1401
	
 	.word	beampos,0xFFFE   | wait before interrupt, avoid losing last bobs lines
    .word	 intreq,0x8010
    .long    -2					
	.ascii	"ENDCPLST"

	* aligning on 8 bytes so .align will work
	* in the next datachip sections
	.align	8
	
		.section .bsschip

bg_screen_backbuffer_data:
	ds.b	BG_SCREEN_SIZE
bg_screen_data_1:
	ds.b	BG_SCREEN_SIZE
	.ifne  OPT_ENABLE_DOUBLE_BUFFERING_BG
bg_screen_data_2:
	ds.b	BG_SCREEN_SIZE
	.endif
	.align	8

		