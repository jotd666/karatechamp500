
*
* 68k transcode by JOTD in 2023 using (https://github.com/jotd666/amiga68ktools)
  
* register conventions (imposed by z80268k mostly) are as follows:
*
* A: D0
* B: D1
* C: D2
* BC: manual
* D: D3
* E: D4
* DE: A1 or D3
* H: D5
* L: D6
* HL: A0 or D6 (video addresses)
* carry: manual, using D7 (push/pop af has no portable equivalent as SR is privileged on 68020+)
*
*
* Karate Champ VS 2. Reverse-engineering attempt by JOTD, focusing on 2 points:
* - CPU A.I.
* - animations
*
* CF02: time when entering highscore (BCD)
*
* current level info is propagated at 3 locations which mean different things:
*
* C0DC: number (1ST, 2ND...)
* C900: map index (picture, girl)
* C910: skill level (see below)
* background_and_state_bits_C911: background+state bits

* C028: attack flags (red player/red cpu), can be 08,09,0A TODO figure out when????

* nb_credits_minus_one_C024: 0 when no credit, then if coin is inserted, set to 1, then
* immediately decreased, while showing "press 1P button" screen

* C910: skill level / speed of computer
* 0: slow => 12: super fast. $10 seems a threshold
* aggressivity is also increased
* increasing skill level dynamically works: computer goes super ninja)
*
* C556-59: 4 bytes looks like counters. When move is completed all 4 values are 8

* C02D
* players_type_human_or_cpu_flags_C02D: 05 1 player vs CPU, 0F 2 players. Changing dynamically works too!

* note: there are 4 structures C200, C220, C240, C260... there are copies of data for instance C229/C22A are copied
* to C269/C26A. Not sure of everything that's written below in terms of addresses...
* C200/C240: player 1 structures
* C220/C260: player 1 structures


* C220: another structure, A.I. related, probably sharing both parties characteristics
* TODO: figure out more values from that structure, specially:
* +07/+08: frame id/pointer on frame structure of own player, used as input of check_hl_in_ix_list_B009 by A.I
*  so the CPU can recognize the moves
* +09 white player x ($20 min $DF max)
* +0A: current move index (at least during practice)
* +0B/+0C: frame id, like 07/08 for opponent player. Note: bit 8 of C22C set: opponent facing right, maybe
*     only important for frame display
* +0D opponent player x
* +0E oppnent move index
* +0F ($C20F): player logical distance, often addressed as  bit  7,(iy+$0f)
* distance seems to be computed from the backs of the players
* bit 7 set => means current player is turning his back to opponent)
* then
* 0: back 2 back distance > 0x70
* 1-4: opponent faces current player (which can turn its back to opponent, see bit 7)
* 1: back 2 back distance > 0x58
* 2: back 2 back distance > 0x40
* 3: back 2 back distance > 0x28
* 4: back 2 back distance > 0x10
* 5-7: opponent turns back to current player (which can turn its back to opponent, see bit 7)
* 5: back 2 back distance > 0x60
* 6: back 2 back distance > 0x30
* 7: back 2 back distance > 0x18
* 8: smaller distance (<= 0x10/0x18) (at least one player must turn his back)
*
* there's a $10 (8 ?) offset depending on facing

* C240: player 1 structure
* +2: 0 when not animated, else number of ticks to stay in the current animation frame
* +7,8: animation related. Bit 7 of C248: facing direction
* C249 (+$9): player 1 x coord. Ranges $20 (32 top left) to $DF (223 right), starts at 0x30
* C24A (+$A): player 1 y coord. $E0 when fighting. Practice:
* C24B (+$B): player 1 current move: codes below
* C24C (+$C): rough distance 0-4
* 0: far
* 1: intermediate, facing other player  (regardless of other player facing direction)
* 2: very close, facing other player   ("")
* 3: intermediate, turning back to other player  ("")
* 4: very close, turning back to other player    ("")
*
*
* C260: player 2 structure
* C269 (+$9): x coord. starts at 0xD0
* C26A (+$A): y coord. $E0 when fighting. Practice: $90
* C26B: player 2 current move (see codes below). Also set during "practice"
* C26C: player 2 rough distance to player 1 0 (same as C24C for second player)
*
* for instance if white is on the left (facing right) and red is on the right, close (facing right)
* the value of
* C24C is: 02
* C26C is: 04
*
* changing C249 immediately reflects on player 1 (white) moving x wise
* changing C269 immediately reflects on player 2 (red) moving x wise
* players can't be exactly at the same position. At least $10 distance is required
* (setting values too close to each other results in game correcting them, same for min/max)
*

* the codes don't match exact moves, but rather the attack type
* there is often only one attack type (back kick) but sometimes there are
* several: example with front kick and weak reverse punch, that only differ
* by attack distance
*
* values marked with "**" trigger the relevant moves only when injecting
* them by setting a at AB56. Injecting 07 doesn't make CPU turn around, but
* does something else.
*
* also attacks can be triggered in other places

* 0x00: not moving, guard
* 0x01: moving back
* 0x02: moving forward
* 0x03: pre-jump (jump to avoid low blow?)
* 0x04: crouch
* 0x05: back kick
* 0x06: ** back kick
* 0x07: turn around (only CPU can do that without using an aborted back jump/round kick)
* 0x08: jumping back kick
* 0x09: foot sweep (back)
* 0x0A: front kick (can also be small reverse punch at short range apparently)
* 0x0B: back round kick
* 0x0C: lunge punch (medium 200-400 forward+forward)
* 0x0D: jumping side kick
* 0x0E: ** foot sweep (front)
* 0x0F: round kick
* 0x10: lunge punch (high 300-600 rear+up)
* 0x11: lunge punch (high 500-1000 forward+up)
* 0x12: rear sommersault
* 0x13: reverse punch (crouch 400-800)
* 0x14: low kick
* 0x15: ** low kick
* 0x16: ** low kick
* 0x17: front sommersault
* 0x18: foot sweep (front)

* difficulty level only has an effect before "CMP" level number 16
* in CMP (champ) level and stage 16 (brige CMP if I'm not mistaken),
* difficulty dip switches are ignored, game is just super fast
* and super hard
*
*A.I: how computer maintains its moves ?
*
* - attack moves: once the attack went through (and failed), depending
*   on the skill level, computer waits a while with the move frozen
*   (including jumping moves, which looks a bit weird). In champion level
*   from level 16, there is no wait at all.
* - blocking moves: maintaned as long as the opponent is performing
*   an attack move with a matching attack height

* I should get more info about player_2_attack_flags_C028 what does the values mean (09,0A...)
* probably related to animation frames not to A.I. so less interesting

* VS Version Info:
* ---------------
* Memory Map:
* Main CPU
* 0000-bfff ROM (encrypted)
* c000-cfff RAM
* d000-d3ff char videoram
* d400-d7ff color videoram
* d800-d8ff sprites
* e000-ffff ROM (encrypted)

* IO Ports:
* Main CPU
* INPUT  00 = Player 1 Controls - ( ACTIVE LOW )
* INPUT  40 = Player 2 Controls - ( ACTIVE LOW )
* INPUT  80 = Coins and Start Buttons - ( ACTIVE LOW )
* INPUT  C0 = Dip Switches - ( ACTIVE LOW )
* OUTPUT 00 = Screen Flip
* OUTPUT 01 = CPU Control
*                 bit 0 = external nmi enable
* OUTPUT 02 = Sound Reset
* OUTPUT 40 = Sound latch write
*
* Sound CPU
* INPUT  01 = Sound latch read
* OUTPUT 00 = AY8910 #1 data write
* OUTPUT 01 = AY8910 #1 control write
* OUTPUT 02 = AY8910 #2 data write
* OUTPUT 03 = AY8910 #2 control write
* OUTPUT 04 = MSM5205 write
* OUTPUT 05 = CPU Control
*                 bit 0 = MSM5205 trigger
*                 bit 1 = external nmi enable


    .global karate_champ_irq
    .global karate_champ_reset

	.ifdef	__amiga__
	.include "karate_champ_ram.68k"
	.align	2
	.endif

karate_champ_irq:
	rts
	
karate_champ_reset:
	* default: 1 update/irq call
	* we need 60 updates / second so on amiga PAL
	* we need to set this variable to 2 once out of 5 calls
	move.b	#1,vb_ticks_count
	lea		stack_top_CF00,sp
l_0000:
	jra	startup_B045                       	| [jp   startup_B045]
	
* routines called by the main scheduler at B502
task_address_table_0020:
	.long	task_5250                           	|  $0020
	.long	task_53d2                           	|  $0022
	.long	task_544f                           	|  $0024
	.long	task_6491                           	|  $0026
	.long	task_6529                           	|  $0028
	.long	task_7c5d                           	|  $002a
	.long	task_6f89                           	|  $002c
	.long	task_6622                           	|  $002e
	.long	task_755b                           	|  $0030
	.long	task_7657                           	|  $0032
	.long	task_3a9c                           	|  $0034
	.long	task_3a9c                           	|  $0036
	.long	task_illegal
	.long	task_illegal
	.long	task_illegal
	.long	task_6d5e                           	|  $003e
	.long	task_47d6                           	|  $0040
	.long	task_47d6                           	|  $0042
	.long	task_47d6                           	|  $0044
	.long	task_47d6                           	|  $0046
	.long	task_50f2                           	|  $0048
	.long	task_b099                           	|  $004a
	.long	task_b09c                           	|  $004c
	.long	task_b09f                           	|  $004e

* stubs
task_illegal:
	illegal
	nop
	
l_7ad6:
l_5974:
l_b0b4:
l_5925:
l_78ea:	
l_b078:	
l_b07b:	
l_5f2a:
l_5bf4:
l_7a89:
l_b08d:
l_5836:
l_58ff:
l_4d84:
l_56f8:
l_5f09:
l_58c7:
l_e000:
	bsr		osd_break
	nop
	nop
	nop
	illegal
		
task_544f:   
task_6491:   
task_6529:   
task_7c5d:   
task_6f89:   
task_6622:   
task_755b:   
task_7657:   
task_3a9c:
task_6d5e:   
task_47d6:   
task_50f2:   
task_b099:   
task_b09c:   
task_b09f:
	illegal

task_5250:
	clr.b	d0                               	| [$5250: ld   a,$00]
	lea	map_index_C900,a2              	| [$5252: ld   ix,map_index_C900]
	move.b	d0,(0x00,a2)                    	| [$5256: ld   (ix+$00),a]
	lea	table_53CC(pc),a0                  	| [$5259: ld   hl,table_53CC]
	move.b	d6,(0x02,a2)                    	| [$525c: ld   (ix+$02),l]
	move.b	d5,(0x03,a2)                    	| [$525f: ld   (ix+$03),h]
	move.b	(a0),d0                         	| [$5262: ld   a,(hl)]
	move.b	d0,(0x01,a2)                    	| [$5263: ld   (ix+$01),a]
l_5266:
	move.b	players_type_human_or_cpu_flags_C02D,d0	| [$5266: ld   a,(players_type_human_or_cpu_flags_C02D)]
	move.b	d0,unknown_C032                 	| [$5269: ld   (unknown_C032),a]
	move.b	#0x01,d0                        	| [$526c: ld   a,$01]
	jbsr	schedule_task_to_start_B057                 	| [$526e: call schedule_task_to_start_B057]
	tst.b	d0                               	| [$5271: and  a]
	beq.b	0f
	jbsr	display_error_text_B075           	| [$5272: call nz,display_error_text_B075]
0:
	move.b	#0x80,d0                        	| [$5275: ld   a,$80]
	jbsr	stop_sound_b0ae                            	| [$5277: call $B0AE]
	move.b	dip_switches_copy_C030,d0       	| [$527a: ld   a,(dip_switches_copy_C030)]
	btst.b	#7,d0                           	| [$527d: bit  7,a] free play bit
	jeq	l_5287                             	| [$527f: jp   z,$5287]
	move.b	#0x03,d0                        	| [$5282: ld   a,$03]
	move.b	d0,nb_credits_minus_one_C024    	| [$5284: ld   (nb_credits_minus_one_C024),a]
l_5287:
	clr.b	d0                               	| [$5287: ld   a,$00]
	jbsr	suspend_task_B05A            	| [$5289: call suspend_task_B05A]
	jbsr	set_normal_screen_b060                            	| [$528c: call $B060]
	move.b	#0x01,d0                        	| [$528f: ld   a,$01]
	jbsr	unsuspend_tasks_b015                            	| [$5291: call $B015]
	move.b	nb_credits_minus_one_C024,d0    	| [$5294: ld   a,(nb_credits_minus_one_C024)]
												| [$5297: and  a]
* after game over check if there are still credits
	jeq	task_5250                             	| [$5298: jp   z,$5250]
	lea	map_index_C900,a2              	| [$529b: ld   ix,map_index_C900]
	lea	unknown_C908,a3                	| [$529f: ld   iy,unknown_C908]
	clr.b	d0                               	| [$52a3: ld   a,$00]
	move.b	d0,(0x00,a2)                    	| [$52a5: ld   (ix+$00),a]
	move.b	d0,(0x00,a3)                    	| [$52a8: ld   (iy+$00),a]
	lea	table_534d(pc),a0                  	| [$52ab: ld   hl,table_534d]
	move.b	(a0),d0                         	| [$52ae: ld   a,(hl)]
	move.b	d0,(0x01,a2)                    	| [$52af: ld   (ix+$01),a]
	move.b	d0,(0x01,a3)                    	| [$52b2: ld   (iy+$01),a]
	move.b	d6,(0x02,a2)                    	| [$52b5: ld   (ix+$02),l]
	move.b	d6,(0x02,a3)                    	| [$52b8: ld   (iy+$02),l]
	move.b	d5,(0x03,a2)                    	| [$52bb: ld   (ix+$03),h]
	move.b	d5,(0x03,a3)                    	| [$52be: ld   (iy+$03),h]
	clr.b	d0                               	| [$52c1: ld   a,$00]
	move.b	d0,(0x04,a2)                    	| [$52c3: ld   (ix+$04),a]
	move.b	d0,(0x04,a3)                    	| [$52c6: ld   (iy+$04),a]
	move.b	d0,(0x05,a2)                    	| [$52c9: ld   (ix+$05),a]
	move.b	d0,(0x05,a3)                    	| [$52cc: ld   (iy+$05),a]
	move.b	d0,(0x06,a2)                    	| [$52cf: ld   (ix+$06),a]
	move.b	d0,(0x06,a3)                    	| [$52d2: ld   (iy+$06),a]
	move.b	d0,(0x07,a2)                    	| [$52d5: ld   (ix+$07),a]
	move.b	d0,(0x07,a3)                    	| [$52d8: ld   (iy+$07),a]
	move.b	d0,level_number_C0DC            	| [$52db: ld   (level_number_C0DC),a]
	move.b	d0,unknown_C0DD                 	| [$52de: ld   (unknown_C0DD),a]
	move.b	d0,unknown_C0DE                 	| [$52e1: ld   (unknown_C0DE),a]
	move.b	d0,unknown_C0DF                 	| [$52e4: ld   (unknown_C0DF),a]
	move.b	d0,unknown_C0E0                 	| [$52e7: ld   (unknown_C0E0),a]
	move.b	d0,unknown_C0E1                 	| [$52ea: ld   (unknown_C0E1),a]
	move.b	d0,unknown_C0E2                 	| [$52ed: ld   (unknown_C0E2),a]
	move.b	d0,unknown_C0E3                 	| [$52f0: ld   (unknown_C0E3),a]
	move.b	d0,unknown_C0E4                 	| [$52f3: ld   (unknown_C0E4),a]
	move.b	d0,unknown_C0E5                 	| [$52f6: ld   (unknown_C0E5),a]
	lea	players_type_human_or_cpu_flags_C02D,a0	| [$52f9: ld   hl,players_type_human_or_cpu_flags_C02D]
	bset.b	#0,(a0)                         	| [$52fc: set  0,(hl)]
	bset.b	#2,(a0)                         	| [$52fe: set  2,(hl)]
	lea	nb_credits_minus_one_C024,a0   	| [$5300: ld   hl,nb_credits_minus_one_C024]
	move.b	(a0),d0                         	| [$5303: ld   a,(hl)]
	subq.b	#0x01,d0                        	| [$5304: sub  $01]
*daa
	move.b	d0,(a0)                         	| [$5307: ld   (hl),a]
	jbsr	clear_C7xx_B01E                    	| [$5308: call $B01E]
	move.b	#0x01,d0                        	| [$530b: ld   a,$01]
	jbsr	suspend_task_B05A            	| [$530d: call suspend_task_B05A]
	move.w	#0x003C,d1                      	| [$5310: ld   bc,$003C] 60
	jbsr	fill_video_and_attribute_memory_B030                    	| [$5313: call $B030]
	move.b	#0x80,d0                        	| [$5316: ld   a,$80]
	jbsr	play_sound_B072                   	| [$5318: call play_sound_B072]
l_531b:
	jbsr	disable_interrupts_B0BD                            	| [$531b: call $B0C0]
	jbsr	display_start_message_7b92                           	| [$531e: call $7B92]
	jbsr	display_credits_7C1C                            	| [$5321: call $7C1C]
	jbsr	check_coin_ports_B069                            	| [$5324: call $B069]
	btst.b	#2,d0                           	| [$5327: bit  2,a]
	jne	l_5266                             	| [$5329: jp   nz,$5266]
	move.b	nb_credits_minus_one_C024,d0    	| [$532c: ld   a,(nb_credits_minus_one_C024)]
	tst.b	d0                               	| [$532f: and  a]
	jeq	l_531b                             	| [$5330: jp   z,$531B]
	jbsr	check_coin_ports_B069                            	| [$5333: call $B069]
	btst.b	#3,d0                           	| [$5336: bit  3,a]
	jeq	l_531b                             	| [$5338: jp   z,$531B]
* set 2 player mode
	lea	players_type_human_or_cpu_flags_C02D(pc),a0	| [$533b: ld   hl,players_type_human_or_cpu_flags_C02D]
	bset.b	#1,(a0)                         	| [$533e: set  1,(hl)]
	bset.b	#3,(a0)                         	| [$5340: set  3,(hl)]
	lea	nb_credits_minus_one_C024(pc),a0   	| [$5342: ld   hl,nb_credits_minus_one_C024]
	move.b	(a0),d0                         	| [$5345: ld   a,(hl)]
	subq.b	#0x01,d0                        	| [$5346: sub  $01]
*daa
	move.b	d0,(a0)                         	| [$5349: ld   (hl),a]
	jra	l_5266                             	| [$534a: jp   $5266]
table_534d:
	dc.b	0x53,0x27,0x07,0x37,0x17,0x55,0x24,0x04 | table_534d
	dc.b	0x34,0x14,0x55,0x22,0x02,0x32,0x12,0x55 | $5355
	dc.b	0x20,0x00,0x30,0x10,0x55,0x2a,0x0a,0x3a | $535d
	dc.b	0x1a,0x55,0x28,0x08,0x38,0x18,0x55,0x25 | $5365
	dc.b	0x05,0x35,0x15,0x55,0x29,0x09,0x39,0x19 | $536d
	dc.b	0x55,0x26,0x06,0x36,0x16,0x55,0x23,0x03 | $5375
	dc.b	0x33,0x13,0x55,0x21,0x01,0x31,0x11,0x55 | $537d
	dc.b	0x2b,0x0b,0x3b,0x1b,0x55,0x27,0x07,0x37 | $5385
	dc.b	0x17,0x55,0x24,0x04,0x34,0x14,0x55,0x22 | $538d
	dc.b	0x02,0x32,0x12,0x55,0x20,0x00,0x30,0x10 | $5395
	dc.b	0x55,0x2a,0x0a,0x3a,0x1a,0x55,0x28,0x08 | $539d
	dc.b	0x38,0x18,0x55,0x25,0x05,0x35,0x15,0x55 | $53a5
	dc.b	0x29,0x09,0x39,0x19,0x55,0x26,0x06,0x36 | $53ad
	dc.b	0x16,0x55,0x23,0x03,0x33,0x13,0x55,0x21 | $53b5
	dc.b	0x01,0x31,0x11,0x55,0x2b,0x0b,0xff,0x4d | $53bd
	dc.b	0x53 | $53c5
table_53C6:
	dc.b	0x54,0x40,0x51
table_53C9:
	dc.b	0x3b,0x54,0x51 | table_53C9
table_53CC:
	dc.b	0xd2,0xd0,0x80,0xff,0xcc,0x53 | table_53CC
	.align	2

task_53d2:
	lea	unknown_C0C8(pc),a0                	| [$53d2: ld   hl,unknown_C0C8]
	move.b	#0x10,d1                        	| [$53d5: ld   b,$10]
l_53d7:
	clr.b	(a0)                             	| [$53d7: ld   (hl),$00]
	addq.w	#1,a0                           	| [$53d9: inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_53d7                             	| [$53da: djnz $53D7]
	jbsr	set_normal_screen_b060                  	| [$53dc: call $B060]
* 1 player mode (and also at game bootup)
	lea	players_type_human_or_cpu_flags_C02D(pc),a0	| [$53df: ld   hl,players_type_human_or_cpu_flags_C02D]
	bset.b	#2,(a0)                         	| [$53e2: set  2,(hl)]
l_53e4:
	move.b	#0x80,d0                        	| [$53e4: ld   a,$80]
	jbsr	play_sound_B072                   	| [$53e6: call play_sound_B072]
	move.b	#0x02,d0                        	| [$53e9: ld   a,$02]
	jbsr	unsuspend_tasks_b015              	| [$53eb: call unsuspend_tasks_b015]
l_53ee:
	jbsr	clear_C7xx_B01E                   	| [$53ee: call clear_C7xx_B01E]
	move.b	#0x01,d0                        	| [$53f1: ld   a,$01]
	jbsr	suspend_task_B05A                 	| [$53f3: call suspend_task_B05A]
	tst.b	d0                               	| [$53f6: and  a]
	beq	0f
	jbsr	display_error_text_B075           	| [$53f7: call nz,display_error_text_B075]
0:
	move.w	#0x003C,d1                      	| [$53fa: ld   bc,$003C] 60
	jbsr	fill_video_and_attribute_memory_B030	| [$53fd: call fill_video_and_attribute_memory_B030]
	lea	unknown_C908(pc),a0                	| [$5400: ld   hl,unknown_C908]
	move.b	players_type_human_or_cpu_flags_C02D,d0	| [$5403: ld   a,(players_type_human_or_cpu_flags_C02D)]
	btst.b	#2,d0                           	| [$5406: bit  2,a]
	jeq	l_540e                             	| [$5408: jp   z,$540E]
* copy the contents of C900 to C907 (8 bytes)
	lea	map_index_C900(pc),a0              	| [$540b: ld   hl,map_index_C900]
l_540e:
	lea	computer_skill_C910(pc),a1         	| [$540e: ld   de,computer_skill_C910]
	move.w	#0x0008,d1                      	| [$5411: ld   bc,$0008] 8
	jbsr	ldir                              	| [$5414: ldir]
	move.b	#0x03,d0                        	| [$5416: ld   a,$03]
	jbsr	schedule_task_to_start_B057       	| [$5418: call schedule_task_to_start_B057]
	tst.b	d0                               	| [$541b: and  a]
	beq.b	0f
	jbsr	display_error_text_B075           	| [$541c: call nz,display_error_text_B075]
0:
	move.b	#0x02,d0                        	| [$541f: ld   a,$02]
	jbsr	schedule_task_to_start_B057       	| [$5421: call schedule_task_to_start_B057]
	tst.b	d0                               	| [$5424: and  a]
	beq.b	0f
	jbsr	display_error_text_B075           	| [$5425: call nz,display_error_text_B075]
0:
	move.b	#0x05,d0                        	| [$5428: ld   a,$05]
	jbsr	schedule_task_to_start_B057       	| [$542a: call schedule_task_to_start_B057]
	tst.b	d0                               	| [$542d: and  a]
	beq.b	0f
	jbsr	display_error_text_B075           	| [$542e: call nz,display_error_text_B075]
0:
	move.b	#0x0F,d0                        	| [$5431: ld   a,$0F]
	jbsr	schedule_task_to_start_B057       	| [$5433: call schedule_task_to_start_B057]
	tst.b	d0                               	| [$5436: and  a]
	beq.b	0f
	jbsr	display_error_text_B075           	| [$5437: call nz,display_error_text_B075]
0:
	clr.b	d0                               	| [$543a: ld   a,$00]
	jbsr	suspend_task_B05A                 	| [$543c: call suspend_task_B05A]
	jbsr	l_5974                            	| [$543f: call $5974]
	tst.b	d0                               	| [$5442: and  a]
	jeq	l_53e4                             	| [$5443: jp   z,$53E4]
	clr.b	d0                               	| [$5446: ld   a,$00]
	move.b	d0,d1                           	| [$5448: ld   b,a]
	jbsr	task_manipulation_B05D            	| [$5449: call task_manipulation_B05D]
	jbsr	warm_reboot_B051                  	| [$544c: call warm_reboot_B051]
l_544f:
	jbsr	l_7a89                            	| [$544f: call $7A89]
	jbsr	l_7ad6                            	| [$5452: call $7AD6]
	jbsr	is_title_screen_demo_mode_B0B1    	| [$5455: call is_title_screen_demo_mode_B0B1]
	tst.b	d0                               	| [$5458: and  a]
	jeq	l_5464                             	| [$5459: jp   z,$5464]
	jbsr	l_b0b4                            	| [$545c: call $B0B4]
	clr.b	d0                               	| [$545f: ld   a,$00]
	jbsr	l_b018                            	| [$5461: call $B018]
l_5464:
	move.b	background_and_state_bits_C911,d0	| [$5464: ld   a,(background_and_state_bits_C911)]
	bclr.b	#7,d0                           	| [$5467: res  7,a]
	asl.b	#2,d0                            	| [$5469: sla  a] *4 (long pointer)
	clr.w	d1                               	| [$546c: ld   b,$00]
	move.b	d0,d1                           	| [$546b: ld   c,a]
	lea	jump_table_547B(pc),a2             	| [$546e: ld   ix,jump_table_547B]
	add.w	d1,a2                            	| [$5472: add  ix,bc]
	move.l	(a2),a0                    		| [$5474: ld   l,(ix+$00)]
											| [$5477: ld   h,(ix+$01)]
	jra	(a0)                               	| [$547a: jp   (hl)]
	

jump_table_547B:
	.long	l_5529
	.long	l_5529
	.long	l_5529
	.long	l_5529
	.long	l_5529
	.long	l_5529
	.long	l_5529
	.long	l_5529
	.long	l_5529
	.long	l_5529
	.long	l_5529
	.long	l_5529
	.long	l_5529
	.long	l_5529
	.long	l_5529
	.long	l_5529
	.long	l_56f8
	.long	l_b084
	.long	l_4d84
	.long	l_56f8
	.long	l_b087
	.long	l_56f8
	.long	l_4d84
	.long	l_56f8
	.long	l_4d84
	.long	l_b08a
	.long	l_b08d
	.long	l_4d84
	.long	0
	.long	0
	.long	0
	.long	0
	.long	l_58c7
	.long	l_58c7
	.long	l_58c7
	.long	l_58c7
	.long	l_58c7
	.long	l_58c7
	.long	l_58c7
	.long	l_58c7
	.long	l_58c7
	.long	l_58c7
	.long	l_58c7
	.long	l_58c7
	.long	l_58c7
	.long	l_58c7
	.long	l_58c7
	.long	l_58c7
	.long	l_58ff
	.long	l_58ff
	.long	l_58ff
	.long	l_58ff
	.long	l_58ff
	.long	l_58ff
	.long	l_58ff
	.long	l_58ff
	.long	l_58ff
	.long	l_58ff
	.long	l_58ff
	.long	l_58ff
	.long	l_58ff
	.long	l_58ff
	.long	l_58ff
	.long	l_58ff
	.long	l_5925
	.long	l_5925
	.long	l_5925
	.long	l_5925
	.long	l_5925
	.long	l_5925
	.long	l_5925
	.long	l_5925
	.long	l_5925
	.long	l_5925
	.long	l_5925
	.long	l_5925
	.long	l_5925
	.long	l_5925
	.long	l_5925
	.long	l_5925
	.long	l_78ea
	.long	l_b078
	.long	l_b07b
	.long	l_5f2a
	.long	l_5bf4
	.long	l_5836
	.long	display_error_text_B075


l_5529:
	clr.b	d0                               	| [$5529: ld   a,$00]
	move.b	d0,unknown_C147                 	| [$552b: ld   (unknown_C147),a]
	move.b	d0,unknown_C148                 	| [$552e: ld   (unknown_C148),a]
l_5531:
	move.b	#0x0A,d0                        	| [$5531: ld   a,$0A]
	jbsr	schedule_task_to_start_B057       	| [$5533: call schedule_task_to_start_B057]
	tst.b	d0                               	| [$5536: and  a]
	beq	0f
	jbsr	display_error_text_B075           	| [$5537: call nz,display_error_text_B075]
0:
	move.b	#0x0B,d0                        	| [$553a: ld   a,$0B]
	jbsr	schedule_task_to_start_B057       	| [$553c: call schedule_task_to_start_B057]
	tst.b	d0                               	| [$553f: and  a]
	beq	0f
	jbsr	display_error_text_B075           	| [$5540: call nz,display_error_text_B075]
0:
	move.b	#0x04,d0                        	| [$5543: ld   a,$04]
	jbsr	schedule_task_to_start_B057       	| [$5545: call schedule_task_to_start_B057]
	move.b	#0x03,d0                        	| [$5548: ld   a,$03]
	jbsr	schedule_task_to_start_B057       	| [$554a: call schedule_task_to_start_B057]
	move.b	#0x07,d0                        	| [$554d: ld   a,$07]
	jbsr	schedule_task_to_start_B057       	| [$554f: call schedule_task_to_start_B057]
	tst.b	d0                               	| [$5552: and  a]
	beq	0f
	jbsr	display_error_text_B075           	| [$5553: call nz,display_error_text_B075]
0:
	move.b	#0x08,d0                        	| [$5556: ld   a,$08]
	jbsr	schedule_task_to_start_B057       	| [$5558: call schedule_task_to_start_B057]
	tst.b	d0                               	| [$555b: and  a]
	beq	0f
	jbsr	display_error_text_B075           	| [$555c: call nz,display_error_text_B075]
0:
	move.b	#0x09,d0                        	| [$555f: ld   a,$09]
	jbsr	schedule_task_to_start_B057       	| [$5561: call schedule_task_to_start_B057]
	tst.b	d0                               	| [$5564: and  a]
	beq	0f
	jbsr	display_error_text_B075           	| [$5565: call nz,display_error_text_B075]
0:
l_5568:
	clr.b	d0                               	| [$5568: ld   a,$00]
	jbsr	suspend_task_B05A                 	| [$556a: call suspend_task_B05A]
	cmp.b	#0x08,d0                         	| [$556d: cp   $08]
	jne	l_559c                             	| [$556f: jp   nz,$559C]
	move.b	#0x0A,d0                        	| [$5572: ld   a,$0A]
	move.b	#0x08,d1                        	| [$5574: ld   b,$08]
	jbsr	task_manipulation_B05D            	| [$5576: call task_manipulation_B05D]
	move.b	#0x0B,d0                        	| [$5579: ld   a,$0B]
	move.b	#0x08,d1                        	| [$557b: ld   b,$08]
	jbsr	task_manipulation_B05D            	| [$557d: call task_manipulation_B05D]
	move.b	#0x08,d0                        	| [$5580: ld   a,$08]
	move.b	#0x09,d1                        	| [$5582: ld   b,$09]
	jbsr	task_manipulation_B05D            	| [$5584: call task_manipulation_B05D]
	move.b	#0x09,d0                        	| [$5587: ld   a,$09]
	move.b	#0x09,d1                        	| [$5589: ld   b,$09]
	jbsr	task_manipulation_B05D            	| [$558b: call task_manipulation_B05D]
	move.b	#0x07,d0                        	| [$558e: ld   a,$07]
	move.b	#0x08,d1                        	| [$5590: ld   b,$08]
	jbsr	task_manipulation_B05D            	| [$5592: call task_manipulation_B05D]
	tst.b	d0                               	| [$5595: and  a]
	beq	0f
	jbsr	display_error_text_B075           	| [$5596: call nz,display_error_text_B075]
0:
	jra	l_5568                             	| [$5599: jp   $5568]
l_559c:
	cmp.b	#0x01,d0                         	| [$559c: cp   $01]
	jeq	l_55a9                             	| [$559e: jp   z,$55A9]
	cmp.b	#0x02,d0                         	| [$55a1: cp   $02]
	jeq	l_5650                             	| [$55a3: jp   z,$5650]
	jbsr	display_error_text_B075           	| [$55a6: call display_error_text_B075]
l_55a9:
	move.b	#0x80,d0                        	| [$55a9: ld   a,$80]
	jbsr	play_sound_B072                   	| [$55ab: call play_sound_B072]
	move.b	#0x07,d0                        	| [$55ae: ld   a,$07]
	jbsr	unsuspend_task_B054               	| [$55b0: call unsuspend_task_B054]
	move.b	#0x08,d0                        	| [$55b3: ld   a,$08]
	jbsr	unsuspend_task_B054               	| [$55b5: call unsuspend_task_B054]
	move.b	#0x09,d0                        	| [$55b8: ld   a,$09]
	jbsr	unsuspend_task_B054               	| [$55ba: call unsuspend_task_B054]
	move.b	#0x0B,d0                        	| [$55bd: ld   a,$0B]
	jbsr	unsuspend_task_B054               	| [$55bf: call unsuspend_task_B054]
	move.b	players_type_human_or_cpu_flags_C02D,d0	| [$55c2: ld   a,(players_type_human_or_cpu_flags_C02D)]
	btst.b	#2,d0                           	| [$55c5: bit  2,a]
	jeq	l_5614                             	| [$55c7: jp   z,$5614]
	move.b	match_timer_C167,d0             	| [$55ca: ld   a,(match_timer_C167)]
	tst.b	d0                               	| [$55cd: and  a]
	jeq	l_5614                             	| [$55ce: jp   z,$5614]
l_55d1:
	move.b	match_timer_C167,d0             	| [$55d1: ld   a,(match_timer_C167)]
	subq.b	#0x01,d0                        	| [$55d4: sub  $01]
*daa
	move.b	d0,match_timer_C167             	| [$55d7: ld   (match_timer_C167),a]
	jbsr	l_64fb                            	| [$55da: call $64FB]
	move.b	#0x08,d0                        	| [$55dd: ld   a,$08]
	jbsr	play_sound_B072                   	| [$55df: call play_sound_B072]
	move.b	players_type_human_or_cpu_flags_C02D,d0	| [$55e2: ld   a,(players_type_human_or_cpu_flags_C02D)]
	and.b	#0x0C,d0                         	| [$55e5: and  $0C]
	cmp.b	#0x0C,d0                         	| [$55e7: cp   $0C]
	jne	l_55fe                             	| [$55e9: jp   nz,$55FE]
	lea	players_type_human_or_cpu_flags_C02D(pc),a0	| [$55ec: ld   hl,players_type_human_or_cpu_flags_C02D]
	bclr.b	#3,(a0)                         	| [$55ef: res  3,(hl)]
	move.b	#0x01,d0                        	| [$55f1: ld   a,$01]
	jbsr	l_b018                            	| [$55f3: call $B018]
	lea	players_type_human_or_cpu_flags_C02D(pc),a0	| [$55f6: ld   hl,players_type_human_or_cpu_flags_C02D]
	bset.b	#3,(a0)                         	| [$55f9: set  3,(hl)]
	jra	l_5603                             	| [$55fb: jp   $5603]
l_55fe:
	move.b	#0x01,d0                        	| [$55fe: ld   a,$01]
	jbsr	l_b018                            	| [$5600: call $B018]
l_5603:
	move.b	#0x06,d0                        	| [$5603: ld   a,$06]
	jbsr	suspend_task_B05A                 	| [$5605: call suspend_task_B05A]
	move.b	match_timer_C167,d0             	| [$5608: ld   a,(match_timer_C167)]
	tst.b	d0                               	| [$560b: and  a]
	jne	l_55d1                             	| [$560c: jp   nz,$55D1]
	move.b	#0x3C,d0                        	| [$560f: ld   a,$3C]
	jbsr	suspend_task_B05A                 	| [$5611: call suspend_task_B05A]
l_5614:
	move.b	#0x07,d0                        	| [$5614: ld   a,$07]
	jbsr	unsuspend_task_B054               	| [$5616: call unsuspend_task_B054]
	move.b	#0x0A,d0                        	| [$5619: ld   a,$0A]
	jbsr	unsuspend_task_B054               	| [$561b: call unsuspend_task_B054]
	move.b	background_and_state_bits_C911,d0	| [$561e: ld   a,(background_and_state_bits_C911)]
	btst.b	#7,d0                           	| [$5621: bit  7,a]
	jne	l_5643                             	| [$5623: jp   nz,$5643]
	move.b	players_type_human_or_cpu_flags_C02D,d0	| [$5626: ld   a,(players_type_human_or_cpu_flags_C02D)]
	cmp.b	#0x0A,d0                         	| [$5629: cp   $0A]
	jeq	l_5638                             	| [$562b: jp   z,$5638]
	lea	unknown_C148(pc),a0                	| [$562e: ld   hl,unknown_C148]
	addq.b	#1,(a0)                         	| [$5631: inc  (hl)]
	move.b	(a0),d0                         	| [$5632: ld   a,(hl)]
	cmp.b	#0x02,d0                         	| [$5633: cp   $02]
	jcs	l_5531                             	| [$5635: jp   c,$5531]
l_5638:
	lea	unknown_C0E0(pc),a0                	| [$5638: ld   hl,unknown_C0E0]
	jbsr	l_5f09                            	| [$563b: call $5F09]
	move.b	#0x64,d0                        	| [$563e: ld   a,$64]
	jbsr	suspend_task_B05A                 	| [$5640: call suspend_task_B05A]
l_5643:
	move.b	#0x01,d0                        	| [$5643: ld   a,$01]
	move.b	d0,d1                           	| [$5645: ld   b,a]
	jbsr	task_manipulation_B05D            	| [$5646: call task_manipulation_B05D]
	tst.b	d0                               	| [$5649: and  a]
	beq	0f
	jbsr	display_error_text_B075           	| [$564a: call nz,display_error_text_B075]
0:
	jbsr	warm_reboot_B051                  	| [$564d: call warm_reboot_B051]
l_5650:
	move.b	#0x80,d0                        	| [$5650: ld   a,$80]
	jbsr	play_sound_B072                   	| [$5652: call play_sound_B072]
	move.b	#0x07,d0                        	| [$5655: ld   a,$07]
	jbsr	unsuspend_task_B054               	| [$5657: call unsuspend_task_B054]
	move.b	#0x08,d0                        	| [$565a: ld   a,$08]
	jbsr	unsuspend_task_B054               	| [$565c: call unsuspend_task_B054]
	move.b	#0x09,d0                        	| [$565f: ld   a,$09]
	jbsr	unsuspend_task_B054               	| [$5661: call unsuspend_task_B054]
	move.b	#0x0A,d0                        	| [$5664: ld   a,$0A]
	jbsr	unsuspend_task_B054               	| [$5666: call unsuspend_task_B054]
	move.b	players_type_human_or_cpu_flags_C02D,d0	| [$5669: ld   a,(players_type_human_or_cpu_flags_C02D)]
	btst.b	#3,d0                           	| [$566c: bit  3,a]
	jeq	l_56bb                             	| [$566e: jp   z,$56BB]
	move.b	match_timer_C167,d0             	| [$5671: ld   a,(match_timer_C167)]
	tst.b	d0                               	| [$5674: and  a]
	jeq	l_56bb                             	| [$5675: jp   z,$56BB]
l_5678:
	move.b	match_timer_C167,d0             	| [$5678: ld   a,(match_timer_C167)]
	subq.b	#0x01,d0                        	| [$567b: sub  $01]
*daa
	move.b	d0,match_timer_C167             	| [$567e: ld   (match_timer_C167),a]
	jbsr	l_64fb                            	| [$5681: call $64FB]
	move.b	#0x08,d0                        	| [$5684: ld   a,$08]
	jbsr	play_sound_B072                   	| [$5686: call play_sound_B072]
	move.b	players_type_human_or_cpu_flags_C02D,d0	| [$5689: ld   a,(players_type_human_or_cpu_flags_C02D)]
	and.b	#0x0C,d0                         	| [$568c: and  $0C]
	cmp.b	#0x0C,d0                         	| [$568e: cp   $0C]
	jne	l_56a5                             	| [$5690: jp   nz,$56A5]
	lea	players_type_human_or_cpu_flags_C02D(pc),a0	| [$5693: ld   hl,players_type_human_or_cpu_flags_C02D]
	bclr.b	#2,(a0)                         	| [$5696: res  2,(hl)]
	move.b	#0x01,d0                        	| [$5698: ld   a,$01]
	jbsr	l_b018                            	| [$569a: call $B018]
	lea	players_type_human_or_cpu_flags_C02D(pc),a0	| [$569d: ld   hl,players_type_human_or_cpu_flags_C02D]
	bset.b	#2,(a0)                         	| [$56a0: set  2,(hl)]
	jra	l_56aa                             	| [$56a2: jp   $56AA]
l_56a5:
	move.b	#0x01,d0                        	| [$56a5: ld   a,$01]
	jbsr	l_b018                            	| [$56a7: call $B018]
l_56aa:
	move.b	#0x06,d0                        	| [$56aa: ld   a,$06]
	jbsr	suspend_task_B05A                 	| [$56ac: call suspend_task_B05A]
	move.b	match_timer_C167,d0             	| [$56af: ld   a,(match_timer_C167)]
	tst.b	d0                               	| [$56b2: and  a]
	jne	l_5678                             	| [$56b3: jp   nz,$5678]
	move.b	#0x3C,d0                        	| [$56b6: ld   a,$3C]
	jbsr	suspend_task_B05A                 	| [$56b8: call suspend_task_B05A]
l_56bb:
	move.b	#0x07,d0                        	| [$56bb: ld   a,$07]
	jbsr	unsuspend_task_B054               	| [$56bd: call unsuspend_task_B054]
	move.b	#0x0B,d0                        	| [$56c0: ld   a,$0B]
	jbsr	unsuspend_task_B054               	| [$56c2: call unsuspend_task_B054]
	move.b	background_and_state_bits_C911,d0	| [$56c5: ld   a,(background_and_state_bits_C911)]
	btst.b	#7,d0                           	| [$56c8: bit  7,a]
	jne	l_56ea                             	| [$56ca: jp   nz,$56EA]
	move.b	players_type_human_or_cpu_flags_C02D,d0	| [$56cd: ld   a,(players_type_human_or_cpu_flags_C02D)]
	cmp.b	#0x05,d0                         	| [$56d0: cp   $05]
	jeq	l_56df                             	| [$56d2: jp   z,$56DF]
	lea	unknown_C147(pc),a0                	| [$56d5: ld   hl,unknown_C147]
	addq.b	#1,(a0)                         	| [$56d8: inc  (hl)]
	move.b	(a0),d0                         	| [$56d9: ld   a,(hl)]
	cmp.b	#0x02,d0                         	| [$56da: cp   $02]
	jcs	l_5531                             	| [$56dc: jp   c,$5531]
l_56df:
	lea	unknown_C0E3(pc),a0                	| [$56df: ld   hl,unknown_C0E3]
	jbsr	l_5f09                            	| [$56e2: call $5F09]
	move.b	#0x64,d0                        	| [$56e5: ld   a,$64]
	jbsr	suspend_task_B05A                 	| [$56e7: call suspend_task_B05A]
l_56ea:
	move.b	#0x01,d0                        	| [$56ea: ld   a,$01]
	move.b	#0x02,d1                        	| [$56ec: ld   b,$02]
	jbsr	task_manipulation_B05D            	| [$56ee: call task_manipulation_B05D]
	tst.b	d0                               	| [$56f1: and  a]
	beq	0f
	jbsr	display_error_text_B075           	| [$56f2: call nz,display_error_text_B075]
0:
	jbsr	warm_reboot_B051                  	| [$56f5: call warm_reboot_B051]

l_64fb:
	move.b	#0x98,d3                        	| [$64fb: ld   d,$98]
	move.w	#0x05,d5                      	| [$64fd: ld   hl,$050F]
	move.w	#0x0F,d6                      	| [$64fd: ld   hl,$050F]
l_6500:
	move.b	d6,temp_numeric_buffer_CF00     	| [$6500: ld   (temp_numeric_buffer_CF00),hl]
	move.b	d5,temp_numeric_buffer_CF00+1     	| [$6500: ld   (temp_numeric_buffer_CF00),hl]
	st.b	d0                                	| [$6503: ld   a,$FF]
	move.b	d0,unknown_CF06                 	| [$6505: ld   (unknown_CF06),a]
	move.b	match_timer_C167,d0             	| [$6508: ld   a,(match_timer_C167)]
	move.b	d0,d1                           	| [$650b: ld   b,a]
	and.b	#0x0F,d0                         	| [$650c: and  $0F]
	move.b	d0,d6                           	| [$650e: ld   l,a]
	move.b	d3,d5                           	| [$650f: ld   h,d]
	move.b	d6,address_of_current_player_move_byte_CF04	| [$6510: ld   (address_of_current_player_move_byte_CF04),hl]
	move.b	d5,address_of_current_player_move_byte_CF04+1	| [$6510: ld   (address_of_current_player_move_byte_CF04),hl]
	move.b	d1,d0                           	| [$6513: ld   a,b]
	lsr.b	#4,d0                            	| [$6514: srl  a] * 4
	and.b	#0x0F,d0                         	| [$651c: and  $0F]
	move.b	d0,d6                           	| [$651e: ld   l,a]
	move.b	d6,unknown_CF02                 	| [$651f: ld   (unknown_CF02),hl]
	move.b	d5,unknown_CF02+1                 	| [$651f: ld   (unknown_CF02),hl]
	lea	temp_numeric_buffer_CF00,a0    	| [$6522: ld   hl,temp_numeric_buffer_CF00]
	jbsr	display_multicolor_text_B03C      	| [$6525: call display_multicolor_text_B03C]
	rts                                    	| [$6528: ret]

display_start_message_7b92:
	move.b	nb_credits_minus_one_C024,d0    	| [$7b92: ld   a,(nb_credits_minus_one_C024)]
	lea	start_1P_message_7BA6(pc),a0       	| [$7b95: ld   hl,start_1P_message_7BA6]
	cmp.b	#0x00,d0                         	| [$7b98: cp   $00]
	jeq	l_7ba0                             	| [$7b9a: jp   z,$7BA0]
	lea	start_2P_message_7BCA(pc),a0       	| [$7b9d: ld   hl,start_2P_message_7BCA]
l_7ba0:
	move.b	#0x98,d3                        	| [$7ba0: ld   d,$98]
	jbsr	display_text_B039                 	| [$7ba2: call display_text_B039]
	rts                                    	| [$7ba5: ret]
start_1P_message_7BA6:
	dc.b	0x05,0x0a,0x19,0x1b,0x0e,0x1c,0x1c,0x3c | table_7BA6
	dc.b	0x01,0x19,0x3c,0x0b,0x1e,0x1d,0x1d,0x18 | $7bae
	dc.b	0x17,0x3c,0x0f,0x18,0x1b,0xfe,0x09,0x0c | $7bb6
	dc.b	0x1c,0x12,0x17,0x10,0x15,0x0e,0x3c,0x19 | $7bbe
	dc.b	0x15,0x0a,0x22,0xff | $7bc6
start_2P_message_7BCA:
	dc.b	0x05,0x0a,0x19,0x1b,0x0e,0x1c,0x1c,0x3c | table_7BCA
	dc.b	0x01,0x19,0x3c,0x0b,0x1e,0x1d,0x1d,0x18 | $7bd2
	dc.b	0x17,0x3c,0x0f,0x18,0x1b,0xfe,0x09,0x0c | $7bda
	dc.b	0x1c,0x12,0x17,0x10,0x15,0x0e,0x3c,0x19 | $7be2
	dc.b	0x15,0x0a,0x22,0xfe,0x05,0x0e,0x19,0x1b | $7bea
	dc.b	0x0e,0x1c,0x1c,0x3c,0x02,0x19,0x3c,0x0b | $7bf2
	dc.b	0x1e,0x1d,0x1d,0x18,0x17,0x3c,0x0f,0x18 | $7bfa
	dc.b	0x1b,0xfe,0x04,0x10,0x0f,0x12,0x10,0x11 | $7c02
	dc.b	0x1d,0x3c,0x0b,0x0e,0x1d,0x20,0x0e,0x0e | $7c0a
	dc.b	0x17,0x3c,0x19,0x15,0x0a,0x22,0x0e,0x1b | $7c12
	dc.b	0x1c,0xff | $7c1a

display_credits_7C1C:
	lea	credit_text_7C54(pc),a0            	| [$7c1c: ld   hl,credit_text_7C54]
	move.b	#0x98,d3                        	| [$7c1f: ld   d,$98]
	jbsr	display_text_B039                 	| [$7c21: call display_text_B039]
											| [$7c24: ld   hl,$1F1C]
	move.w	#0x1C1F,temp_numeric_buffer_CF00     	| [$7c27: ld   (temp_numeric_buffer_CF00),hl]
* at least during "press 1P button" screen
* check number of credits, maybe to display them
* as there's a "daa" instruction (bcd conversion)
	move.b	nb_credits_minus_one_C024,d0    	| [$7c2a: ld   a,(nb_credits_minus_one_C024)]
	addq.b	#0x01,d0                        	| [$7c2d: add  a,$01]
**daa
	move.b	d0,d1                           	| [$7c30: ld   b,a]
	lea	temp_numeric_buffer_CF00(pc),a2    	| [$7c31: ld   ix,temp_numeric_buffer_CF00]
	and.b	#0x0F,d0                         	| [$7c35: and  $0F]
	move.b	d0,(0x03,a2)                    	| [$7c37: ld   (ix+$03),a]
	move.b	d1,d0                           	| [$7c3a: ld   a,b]
	lsr.b	#4,d0                            	| [$7c3b: srl  a] * 4
	move.b	d0,(0x02,a2)                    	| [$7c43: ld   (ix+$02),a]
	st.b	d0                                	| [$7c46: ld   a,$FF]
	move.b	d0,(0x04,a2)                    	| [$7c48: ld   (ix+$04),a]
	lea	temp_numeric_buffer_CF00(pc),a0    	| [$7c4b: ld   hl,temp_numeric_buffer_CF00]
	move.b	#0x98,d3                        	| [$7c4e: ld   d,$98]
	jbsr	display_text_B039                 	| [$7c50: call display_text_B039]
	rts                                    	| [$7c53: ret]
credit_text_7C54:
	dc.b	0x15,0x1f,0x0c,0x1b,0x0e,0x0d,0x12,0x1d | credit_7C54
	dc.b	0xff | $7c5c
	.align	2
	
unsuspend_tasks_b015:
	jra	unsuspend_tasks_b171                             	| [$b015: jp   unsuspend_tasks_b171]

l_b018:
	jra	l_b1ab                             	| [$b018: jp   $B1AB]


clear_C7xx_B01E:
	jra	clear_C7xx_B2B2                    	| [$b01e: jp   clear_C7xx_B2B2]
clear_zone_B021:
	jra	clear_zone_B2BD                    	| [$b021: jp   clear_zone_B2BD]

fill_video_and_attribute_memory_B030:
	jra	fill_video_and_attribute_memory_B316	| [$b030: jp   fill_video_and_attribute_memory_B316]

display_text_B039:
	jra	display_text_B357                  	| [$b039: jp   display_text_B357]

display_multicolor_text_B03C:
	jra	display_multicolor_text_B391       	| [$b03c: jp   display_multicolor_text_B391]

startup_B045:
	jra	startup_B469                       	| [$b045: jp   startup_B469]


unsuspend_task_B054:
	jra	unsuspend_task_B5CD                	| [$b054: jp   unsuspend_task_B5CD]

schedule_task_to_start_B057:
	jra	schedule_task_to_start_B620                  	| [$b057: jp   schedule_task_to_start_B620]

warm_reboot_B051:
	trap	#0
	
suspend_task_B05A:
	jra	suspend_task_B65E                  	| [$b05a: jp   suspend_task_B65E]
task_manipulation_B05D:
	jra	task_manipulation_B6AE             	| [$b05d: jp   task_manipulation_B6AE]

set_normal_screen_b060:
	jra	set_normal_screen_bb72                             	| [$b060: jp   $BB72]
check_coin_ports_B069:
	jra	check_coin_ports_BB82              	| [$b069: jp   check_coin_ports_BB82]

play_sound_B072:
	jbsr	osd_sound_start
	rts
	
display_error_text_B075:
	jra	display_error_text_B186            	| [$b075: jp   display_error_text_B186]

l_b084:
	jra	l_e000                             	| [$b084: jp   $E000]
l_b087:
	jra	l_e000                             	| [$b087: jp   $E000]
l_b08a:
	jra	l_e000                             	| [$b08a: jp   $E000]


stop_sound_b0ae:
	jra	stop_sound_BBDF                    	| [$b0ae: jp   stop_sound_BBDF]

is_title_screen_demo_mode_B0B1:
	jra	is_title_screen_demo_mode_B27E     	| [$b0b1: jp   is_title_screen_demo_mode_B27E]

disable_interrupts_B0BD:
	jra		disable_interrupts_BBE2
	
unsuspend_tasks_b171:
	cmp.b	#0x18,d0                         	| [unsuspend_tasks_b171: cp   $18]
	bcs.b	0f
	jbsr	display_error_text_B186           	| [$b173: call nc,display_error_text_B186]
0:

	move.l	a3,-(sp)                        	| [$b176: push iy]
l_b178:
	move.w	d0,-(sp)                        	| [$b178: push af]
	jbsr	unsuspend_task_B5CD               	| [$b179: call unsuspend_task_B5CD]
	move.w	(sp)+,d0                        	| [$b17c: pop  af]
	addq.b	#1,d0                           	| [$b17d: inc  a]
	cmp.b	#0x18,d0                         	| [$b17e: cp   $18]
	jne	l_b178                             	| [$b180: jp   nz,$B178]
	move.l	(sp)+,a3                        	| [$b183: pop  iy]
	rts                                    	| [$b185: ret]

display_error_text_B186:
	move.l	(sp)+,a2                        	| [$b186: pop  ix]
	jbsr	disable_interrupts_BBE2           	| [$b188: call disable_interrupts_BBE2]
	move.w	d0,-(sp)                        	| [$b18b: push af]
	movem.w	d1/d2,-(sp)                    	| [$b18c: push bc]
	move.l	a4,-(sp)                        	| [$b18c: push bc]
	movem.w	d3/d4,-(sp)                    	| [$b18d: push de]
	move.l	a1,-(sp)                        	| [$b18d: push de]

	move.l	a0,-(sp)                        	| [$b18e: push hl]

	move.l	a3,-(sp)                        	| [$b18f: push iy]
	lea	error_text_B1A3(pc),a0             	| [$b191: ld   hl,error_text_B1A3] ERROR
	move.b	#0x98,d3                        	| [$b194: ld   d,$98]
	jbsr	display_text_B357                 	| [$b196: call display_text_B357]
	move.l	(sp)+,a3                        	| [$b199: pop  iy]
	move.l	(sp)+,a0                        	| [$b19b: pop  hl]
	move.l	(sp)+,a1                        	| [$b19c: pop  de]
	movem.w	(sp)+,d3/d4                    	| [$b19c: pop  de]
	move.l	(sp)+,a4                        	| [$b19d: pop  bc]
	movem.w	(sp)+,d1/d2                    	| [$b19d: pop  bc]
	move.w	(sp)+,d0                        	| [$b19e: pop  af]
* infinite loop, all registers are preserved, inc. call address
* probably used by the devs as an "assert failed" routine, where they could
* track down abnormal values before it really crashes
l_b19f:
	bsr		osd_break                                    	| [$b19f: nop]
	jra	l_b19f                             	| [$b1a0: jp   $B19F]

error_text_B1A3:
	dc.b	0x0e,0x10,0x0e,0x1b,0x1b,0x18,0x1b,0xff  | "ERROR"
	.align	2
	
l_b1ab:
	move.l	a3,-(sp)                        	| [$b1ab: push iy]
	move.w	d0,-(sp)                        	| [$b1ad: push af]
	lea	unknown_C0C8(pc),a2                	| [$b1ae: ld   ix,unknown_C0C8]
	move.b	players_type_human_or_cpu_flags_C02D,d0	| [$b1b2: ld   a,(players_type_human_or_cpu_flags_C02D)]
	and.b	#0x0C,d0                         	| [$b1b5: and  $0C]
	cmp.b	#0x0C,d0                         	| [$b1b7: cp   $0C]
	jeq	l_b1c4                             	| [$b1b9: jp   z,$B1C4]
	btst.b	#2,d0                           	| [$b1bc: bit  2,a]
	jne	l_b1de                             	| [$b1be: jp   nz,$B1DE]
	jra	l_b1da                             	| [$b1c1: jp   $B1DA]
l_b1c4:
	move.b	player_2_attack_flags_C028,d0   	| [$b1c4: ld   a,(player_2_attack_flags_C028)]
	cmp.b	#0x0A,d0                         	| [$b1c7: cp   $0A]
	jeq	l_b1de                             	| [$b1c9: jp   z,$B1DE]
	cmp.b	#0x0B,d0                         	| [$b1cc: cp   $0B]
	jeq	l_b1da                             	| [$b1ce: jp   z,$B1DA]
	move.w	(sp)+,d0                        	| [$b1d1: pop  af]
	move.w	d0,-(sp)                        	| [$b1d2: push af]
	tst.b	d0                               	| [$b1d3: and  a]
	beq	0f
	jbsr	display_error_text_B186           	| [$b1d4: call nz,display_error_text_B186]
0:
	jra	l_b1de                             	| [$b1d7: jp   $B1DE]
l_b1da:
	lea	unknown_C0D0(pc),a2                	| [$b1da: ld   ix,unknown_C0D0]
l_b1de:
	move.w	(sp)+,d0                        	| [$b1de: pop  af]
	add.b	(0x01,a2),d0                     	| [$b1df: add  a,(ix+$01)]
*daa
	move.b	d0,(0x01,a2)                    	| [$b1e3: ld   (ix+$01),a]
	move.b	(0x00,a2),d0                    	| [$b1e6: ld   a,(ix+$00)]
*adc  a,$00
*daa
	move.b	d0,(0x00,a2)                    	| [$b1ec: ld   (ix+$00),a]
	move.w	#0xC0,d5		             	| [$b1ef: ld   hl,(unknown_C0C0)]
	move.w	#0xC0,d6		             	| [$b1ef: ld   hl,(unknown_C0C0)]
	move.b	d6,d0                           	| [$b1f2: ld   a,l]
	move.b	d5,d6                           	| [$b1f3: ld   l,h]
	move.b	d0,d5                           	| [$b1f4: ld   h,a]
	move.w	(0x00,a2),d1                    	| [$b1f5: ld   b,(ix+$00)]
												| [$b1f8: ld   c,(ix+$01)]
												| [$b1fb: and  a]
	sub.w	d1,a0											| [sbc  hl,bc]
	jcc	l_b20c                             	| [$b1fe: jp   nc,$B20C]
	move.w	#0xC0,d2               	| [$b201: ld   de,unknown_C0C0]
	move.w	#0xC0,d3               	| [$b201: ld   de,unknown_C0C0]

	move.l	a2,a0                        	| [$b204: push ix]
											| [$b206: pop  hl]
	move.w	#0x0003,d1                      	| [$b207: ld   bc,$0003] 3
	jbsr	ldir                              	| [$b20a: ldir]
l_b20c:
	move.b	#0xC0,d5                	| [$b20c: ld   hl,unknown_C0C0]
	move.b	#0xC0,d6                	| [$b20c: ld   hl,unknown_C0C0]
	move.b	#0x98,d3                        	| [$b20f: ld   d,$98]
	move.b	background_and_state_bits_C911,d0	| [$b211: ld   a,(background_and_state_bits_C911)]
	bclr.b	#7,d0                           	| [$b214: res  7,a]
	cmp.b	#0x54,d0                         	| [$b216: cp   $54]
	jeq	l_b227                             	| [$b218: jp   z,$B227]
	cmp.b	#0x53,d0                         	| [$b21b: cp   $53]
	jeq	l_b227                             	| [$b21d: jp   z,$B227]
	jbsr	is_title_screen_demo_mode_B27E    	| [$b220: call is_title_screen_demo_mode_B27E]
	tst.b	d0                               	| [$b223: and  a]
	jeq	l_b27b                             	| [$b224: jp   z,$B27B]
l_b227:
	move.b	#0x14,d1                      	| [$b227: ld   bc,$1402]
	move.b	#0x02,d2                      	| [$b227: ld   bc,$1402]
	jbsr	display_text_color_2_B3CE         	| [$b22a: call display_text_color_2_B3CE]
	move.b	#0x14,d1                      	| [$b22d: ld   bc,$1404]
	move.b	#0x04,d2                      	| [$b22d: ld   bc,$1404]
	move.b	background_and_state_bits_C911,d0	| [$b230: ld   a,(background_and_state_bits_C911)]
	bclr.b	#7,d0                           	| [$b233: res  7,a]
	cmp.b	#0x54,d0                         	| [$b235: cp   $54]
	jeq	l_b248                             	| [$b237: jp   z,$B248]
	cmp.b	#0x53,d0                         	| [$b23a: cp   $53]
	jeq	l_b248                             	| [$b23c: jp   z,$B248]
	jbsr	is_title_screen_demo_mode_B27E    	| [$b23f: call is_title_screen_demo_mode_B27E]
	move.b	#0x14,d1                      	| [$b242: ld   bc,$1404]
	move.b	#0x04,d2                      	| [$b242: ld   bc,$1404]
	cmp.b	#0x02,d0                         	| [$b245: cp   $02]
	beq.b	0f
	rts                                    	| [$b247: ret  nz]
0:
l_b248:
	move.b	#0x98,d3                        	| [$b248: ld   d,$98]
	move.b	#0xC0,d5                	| [$b24a: ld   hl,unknown_C0C8]
	move.b	#0xC8,d6                	| [$b24a: ld   hl,unknown_C0C8]
	jbsr	display_text_color_2_B3CE         	| [$b24d: call display_text_color_2_B3CE]
	move.b	unknown_C032,d0                 	| [$b250: ld   a,(unknown_C032)]
	btst.b	#1,d0                           	| [$b253: bit  1,a]
	jeq	l_b27b                             	| [$b255: jp   z,$B27B]
	move.b	#0x14,d1                      	| [$b258: ld   bc,$1406]
	move.b	#0x06,d2                      	| [$b258: ld   bc,$1406]
	move.b	background_and_state_bits_C911,d0	| [$b25b: ld   a,(background_and_state_bits_C911)]
	bclr.b	#7,d0                           	| [$b25e: res  7,a]
	cmp.b	#0x54,d0                         	| [$b260: cp   $54]
	jeq	l_b273                             	| [$b262: jp   z,$B273]
	cmp.b	#0x53,d0                         	| [$b265: cp   $53]
	jeq	l_b273                             	| [$b267: jp   z,$B273]
	jbsr	is_title_screen_demo_mode_B27E    	| [$b26a: call is_title_screen_demo_mode_B27E]
	move.b	#0x14,d1                      	| [$b26d: ld   bc,$1406]
	move.b	#0x06,d2                      	| [$b26d: ld   bc,$1406]
	cmp.b	#0x02,d0                         	| [$b270: cp   $02]
	beq.b	0f
	rts                                    	| [$b272: ret  nz]
0:
l_b273:
	move.b	#0xC0,d5                	| [$b273: ld   hl,unknown_C0D0]
	move.b	#0xD0,d6                	| [$b273: ld   hl,unknown_C0D0]
	move.b	#0x98,d3                        	| [$b276: ld   d,$98]
	jbsr	display_text_color_2_B3CE         	| [$b278: call display_text_color_2_B3CE]
l_b27b:
	move.l	(sp)+,a3                        	| [$b27b: pop  iy]
	rts                                    	| [$b27d: ret]

is_title_screen_demo_mode_B27E:
	move.b	background_and_state_bits_C911,d0	| [$b27e: ld   a,(background_and_state_bits_C911)]
	bclr.b	#7,d0                           	| [$b281: res  7,a]
	cmp.b	#0x50,d0                         	| [$b283: cp   $50] demo mode?
	jcs	l_b28b                             	| [$b285: jp   c,$B28B]
	clr.b	d0                               	| [$b288: ld   a,$00]
	rts                                    	| [$b28a: ret]
l_b28b:
	move.b	#0x02,d0                        	| [$b28b: ld   a,$02]
	rts                                    	| [$b28d: ret]

l_b28e:
	movem.w	d1/d2,-(sp)                    	| [$b28e: push bc]
	move.l	a4,-(sp)                        	| [$b28e: push bc]

	movem.w	d5/D6,-(sp)                        	| [$b28f: push hl]
	movem.w	d1/d2,-(sp)                    	| [$b290: push bc]
	move.l	a4,-(sp)                        	| [$b290: push bc]
	movem.w	d3/d4,-(sp)                    	| [$b291: push de]
	move.l	a1,-(sp)                        	| [$b291: push de]
	jbsr	compute_screen_address_from_XY_B2F6	| [$b292: call compute_screen_address_from_XY_B2F6]
	move.l	(sp)+,a1                        	| [$b295: pop  de]
	movem.w	(sp)+,d3/d4                    	| [$b295: pop  de]
	move.l	(sp)+,a4                        	| [$b296: pop  bc]
	movem.w	(sp)+,d1/d2                    	| [$b296: pop  bc]
l_b297:
	movem.w	d1/d2,-(sp)                    	| [$b297: push bc]
	move.l	a4,-(sp)                        	| [$b297: push bc]
	move.w	d0,-(sp)
	move.b	d4,d0                         	| [$b298: ld   (hl),e]
	jbsr	osd_w_videoram
	move.w	#0x400,d1                     	| [$b299: ld   bc,$0400]
	add.w	d1,d6                            	| [$b29c: add  hl,bc]
	move.b	d3,d0                         	| [$b29d: ld   (hl),d]
	jbsr	osd_w_colorram
	move.w	(sp)+,d0
	move.w	#0x03FF,d1                      	| [$b29e: ld   bc,$03FF]
											| [$b2a1: and  a]
	sub.w	d1,d6							| [sbc  hl,bc]
	move.l	(sp)+,a4                        	| [$b2a4: pop  bc]
	movem.w	(sp)+,d1/d2                    	| [$b2a4: pop  bc]
	subq.b	#1,d1                           	| [$b2a5: dec  b]
	jne	l_b297                             	| [$b2a6: jp   nz,$B297]
	movem.w	(sp)+,d5/D6                        	| [$b2a9: pop  hl]
	subq.b	#1,d5                           	| [$b2aa: dec  h]
	move.l	(sp)+,a4                        	| [$b2ab: pop  bc]
	movem.w	(sp)+,d1/d2                    	| [$b2ab: pop  bc]
	subq.b	#1,d2                           	| [$b2ac: dec  c]
	jne	l_b28e                             	| [$b2ad: jp   nz,$B28E]
	rts                                    	| [$b2b0: ret]
l_b2b1:
	rts                                    	| [$b2b1: ret]

clear_C7xx_B2B2:
	clr.b	d0                               	| [$b2b2: xor  a]
	lea	referee_x_pos_C700,a0          	| [$b2b3: ld   hl,referee_x_pos_C700]
	lea	unknown_C7FB,a4                	| [$b2b6: ld   bc,unknown_C7FB]
	jbsr	fill_zone_with_a_B2CA             	| [$b2b9: call fill_zone_with_a_B2CA]
	rts                                    	| [$b2bc: ret]

* < HL: pointer on zone to clear
* < BC: size
clear_zone_B2BD:
	move.l	(sp)+,a2                        	| [$b2bd: pop  ix] return address in ix
l_b2bf:
	clr.b	(a0)+                             	| [$b2bf: ld   (hl),$00] set to 0
									| [$b2c1: inc  hl] increment hl
	subq.w	#1,d1                           	| [$b2c2: dec  bc] decrement bc counter
											| [$b2c3: ld   a,b] test b=c=0
												| [$b2c4: or   c]
	jne	l_b2bf                             	| [$b2c5: jp   nz,$B2BF] not 0, keep looping
	jra	(a2)      
	

* < a: character to store
* < a0: start address
* < a4: end address (included)
fill_zone_with_a_B2CA:
	addq.w	#1,a4                           	| [$b2ca: inc  bc]
	move.b	d0,d3                           	| [$b2cb: ld   d,a]
l_b2cc:
	move.b	d3,(a0)+                         	| [$b2cc: ld   (hl),d]
	cmp.l	a0,a4										| [$b2cd: inc  hl]
	jne	l_b2cc                             	| [$b2d0: jp   nz,$B2CC]
	rts                                    	| [$b2d8: ret]
	
* < D5/D6: X,Y
* > D6: screen address
compute_screen_address_from_XY_B2F6:
	clr.b	d3                               	| [$b2f6: ld   d,$00]
	move.b	d5,d4                           	| [$b2f8: ld   e,h]
	asl.b	#1,d4                            	| [$b2f9: sla  e]
	roxl.b	#1,d3                           	| [$b2fb: rl   d]
	asl.b	#1,d4                            	| [$b2fd: sla  e]
	roxl.b	#1,d3                           	| [$b2ff: rl   d]
	asl.b	#1,d4                            	| [$b301: sla  e]
	roxl.b	#1,d3                           	| [$b303: rl   d]
	asl.b	#1,d4                            	| [$b305: sla  e]
	roxl.b	#1,d3                           	| [$b307: rl   d]
	asl.b	#1,d4                            	| [$b309: sla  e]
	roxl.b	#1,d3                           	| [$b30b: rl   d] results in DE = H*32
	clr.b	d0                               	| [$b30d: xor  a]
	move.b	d0,d5                           	| [$b30e: ld   h,a]
	lsl.w	#8,d5
	move.b	d6,d5
	
	lsl.w	#8,d3
	move.b	d4,d3
	move.w	#0xD3E0,d6                      	| [$b30f: ld   bc,$D3E0] screen address
	add.w	d5,d6                            	| [$b312: add  hl,bc]

	sub.w	d3,d6							| [sbc  hl,de]
	rts                                    	| [$b315: ret]


* fill video & attribute memory with an uniform value
* < d2: what to set in video memory
* < d1: what to set in attribute memory
*
fill_video_and_attribute_memory_B316:
	move.w	#0xD000,d4                      	| [$b316: ld   hl,$D000]
	move.w	#0xD400,d5                      	| [$b316: ld   hl,$D000]
	move.w	#0x400,d3                      	| [$b31d: ld   de,$0400]
l_b320:
	move.w	d4,d6
	move.b	d2,d0                        	| [$b320: ld   (hl),c]
	jbsr	osd_w_videoram
	move.w	d5,d6
	move.b	d1,d0                    	| [$b324: ld   (ix+$00),b]
	jbsr	osd_w_colorram
	addq.w	#1,d4                           	| [$b327: inc  hl]
	addq.w	#1,d5                           	| [$b328: inc  ix]
	subq.w	#1,d3                           	| [$b32a: dec  de]
	jne	l_b320                             	| [$b32d: jp   nz,$B320]
	rts                                    	| [$b330: ret]

* display text
* <  hl pointer on text
* : format x y text (not in ASCII, tile-index based), ends by $FF
* codes are:
* 0-9: digits
* 10-35: A-Z
* 0x3C: space
* 0xFE: line feed, goto next line
* 0xFF: end

* <  d  color attribute

display_text_B357:

	move.l	a3,-(sp)                        	| [$b357: push iy]
	move.l	a0,a3                        	| [$b359: push hl]
	                        	| [$b35a: pop  iy]
	* a3 points on coords , color, + text
l_b35c:
	* get X
	move.b	(a3)+,d0                    	| [$b35c: ld   a,(iy+$00)]
	move.b	d0,d5                           	| [$b35f: ld   h,a]
											| [$b360: inc  iy]
	* get Y
	move.b	(a3),d0                    	| [$b362: ld   a,(iy+$00)]
	move.b	d0,d6                           	| [$b365: ld   l,a]
	movem.w	d3/d4,-(sp)                    	| [$b366: push de]
	move.l	a1,-(sp)                        	| [$b366: push de]
	jbsr	compute_screen_address_from_XY_B2F6	| [$b367: call compute_screen_address_from_XY_B2F6]
	move.l	(sp)+,a1                        	| [$b36a: pop  de]
	movem.w	(sp)+,d3/d4                    	| [$b36a: pop  de]
l_b36b:
	addq.w	#1,a3                           	| [$b36b: inc  iy]
	move.b	(a3),d0                    	| [$b36d: ld   a,(iy+$00)]
	cmp.b	#0xFF,d0                         	| [$b370: cp   $FF] end of string?
	jeq	l_b38e                             	| [$b372: jp   z,$B38E]
* FE: end of string
	cmp.b	#0xFE,d0                         	| [$b375: cp   $FE]
	jne	l_b37f                             	| [$b377: jp   nz,$B37F]
	addq.w	#1,a3                           	| [$b37a: inc  iy]
	jra	l_b35c                             	| [$b37c: jp   $B35C]
l_b37f:
	jbsr	osd_w_videoram                 	| [$b37f: ld   (hl),a]
											| [$b380: ld   bc,$0400]
	add.w	#0x400,d6                            	| [$b383: add  hl,bc] attribute memory
	move.b	d3,d0
	jbsr	osd_w_colorram                         	| [$b384: ld   (hl),d]
	                      	| [$b385: ld   bc,$0420] next char
	                               	| [$b388: xor  a]
	sub.w	#0x420,d6				| [sbc  hl,bc]
	jra	l_b36b                             	| [$b38b: jp   $B36B]
l_b38e:
	move.l	(sp)+,a3                        	| [$b38e: pop  iy]
	rts                                    	| [$b390: ret]


* display text with possible color change
* <  hl pointer on text
* : format x y text/attribute (not in ASCII, tile-index based), ends by $FF
display_multicolor_text_B391:
	move.l	a3,-(sp)                        	| [$b391: push iy]
	move.l	a0,a3                        	| [$b393: push hl]
	                        	| [$b394: pop  iy]
l_b396:
	move.b	(a3)+,d0                    	| [$b396: ld   a,(iy+$00)]
	move.b	d0,d5                           	| [$b399: ld   h,a]
	                           	| [$b39a: inc  iy]
	move.b	(a3),d0                    	| [$b39c: ld   a,(iy+$00)]
	move.b	d0,d6                           	| [$b39f: ld   l,a]
	jbsr	compute_screen_address_from_XY_B2F6	| [$b3a0: call compute_screen_address_from_XY_B2F6]
l_b3a3:
	addq.w	#1,a3                           	| [$b3a3: inc  iy]
	move.b	(a3),d0                    	| [$b3a5: ld   a,(iy+$00)]
	cmp.b	#0xFF,d0                         	| [$b3a8: cp   $FF]
	jeq	l_b3cb                             	| [$b3aa: jp   z,$B3CB]
	cmp.b	#0xFE,d0                         	| [$b3ad: cp   $FE]
	jne	l_b3b7                             	| [$b3af: jp   nz,$B3B7]
	addq.w	#1,a3                           	| [$b3b2: inc  iy]
	jra	l_b396                             	| [$b3b4: jp   $B396]
l_b3b7:
	jbsr	osd_w_videoram                         	| [$b3b7: ld   (hl),a]
	move.w	#0x400,d1                      	| [$b3b8: ld   bc,$0400]
	add.w	d1,d6                            	| [$b3bb: add  hl,bc]

	addq.w	#1,a3                           	| [$b3bc: inc  iy]
	move.b	(a3),d0                    	| [$b3be: ld   a,(iy+$00)]
	jbsr	osd_w_colorram                  	| [$b3c1: ld   (hl),a]
	move.w	#0x420,d1                      	| [$b3c2: ld   bc,$0420]
	clr.b	d0                               	| [$b3c5: xor  a]
	sub.w	d1,d6							| [sbc  hl,bc]
	jra	l_b3a3                             	| [$b3c8: jp   $B3A3]
l_b3cb:
	move.l	(sp)+,a3                        	| [$b3cb: pop  iy]
	rts                                    	| [$b3cd: ret]

* not sure of what it exactly does. It displays text pointed by A0 at D1/D2
display_text_color_2_B3CE:
	move.l	a0,-(sp)                        	| [$b3ce: push hl]
	movem.w	d3/d4,-(sp)                    	| [$b3cf: push de]
	move.b	d1,d5                           	| [$b3d0: ld   h,b]
	move.b	d2,d6                           	| [$b3d1: ld   l,c]
	jbsr	compute_screen_address_from_XY_B2F6	| [$b3d2: call compute_screen_address_from_XY_B2F6]
	movem.w	(sp)+,d3/d4                    	| [$b3d5: pop  de]
	move.b	#0x03,d1                        	| [$b3d6: ld   b,$03]
	move.l	(sp)+,a3                        	| [$b3d8: pop  iy]
	clr.b	d2                               	| [$b3da: ld   c,$00]
l_b3dc:
	move.b	(a3),d0                    	| [$b3dc: ld   a,(iy+$00)]
	and.b	#0xF0,d0                         	| [$b3df: and  $F0]
	lsr.b	#4,d0                            	| [$b3e1: srl  a] * 4
	tst.b	d0                               	| [$b3e9: and  a]
	jeq	l_b3f2                             	| [$b3ea: jp   z,$B3F2]
	move.b	#0x01,d2                        	| [$b3ed: ld   c,$01]
	jra	l_b3fe                             	| [$b3ef: jp   $B3FE]
l_b3f2:
	addq.b	#1,d2                           	| [$b3f2: inc  c]
	subq.b	#1,d2                           	| [$b3f3: dec  c]
	jne	l_b3fe                             	| [$b3f4: jp   nz,$B3FE]
	subq.b	#1,d1                           	| [$b3f7: dec  b]
	jeq	l_b3fd                             	| [$b3f8: jp   z,$B3FD]
	move.b	#0x3C,d0                        	| [$b3fb: ld   a,$3C]
l_b3fd:
	addq.b	#1,d1                           	| [$b3fd: inc  b]
l_b3fe:
	jbsr	osd_w_videoram                         	| [$b3fe: ld   (hl),a]
	movem.w	d1/d2,-(sp)                    	| [$b3ff: push bc]
	move.w	#0x400,d1                      	| [$b400: ld   bc,$0400]
	add.w	d1,d6                            	| [$b403: add  hl,bc]
	move.w	d0,-(sp)
	move.b	d3,d0
	jbsr	osd_w_colorram                         	| [$b404: ld   (hl),d]
	move.w	(sp)+,d0
	tst.b	d0                               	| [$b405: and  a]
	sub.w	d1,d6							| [sbc  hl,bc]
	move.w	#0x20,d1     	| [$b408: ld   bc,task_address_table_0020]
	clr.b	d0                               	| [$b40b: xor  a]
	sub.w	d1,d6							| [sbc  hl,bc]
	movem.w	(sp)+,d1/d2                    	| [$b40e: pop  bc]
	move.b	(a3),d0                    	| [$b40f: ld   a,(iy+$00)]
	and.b	#0x0F,d0                         	| [$b412: and  $0F]
	jeq	l_b41c                             	| [$b414: jp   z,$B41C]
	move.b	#0x01,d2                        	| [$b417: ld   c,$01]
	jra	l_b428                             	| [$b419: jp   $B428]
l_b41c:
	addq.b	#1,d2                           	| [$b41c: inc  c]
	subq.b	#1,d2                           	| [$b41d: dec  c]
	jne	l_b428                             	| [$b41e: jp   nz,$B428]
	subq.b	#1,d1                           	| [$b421: dec  b]
	jeq	l_b427                             	| [$b422: jp   z,$B427]
	move.b	#0x3C,d0                        	| [$b425: ld   a,$3C]
l_b427:
	addq.b	#1,d1                           	| [$b427: inc  b]
l_b428:
	jbsr	osd_w_videoram                         	| [$b428: ld   (hl),a]
	movem.w	d1/d2,-(sp)                    	| [$b429: push bc]
	move.w	#0x400,d1                      	| [$b42a: ld   bc,$0400]
	add.w	d1,d6                            	| [$b42d: add  hl,bc]
	move.w	d0,-(sp)
	move.b	d3,d0
	jbsr	osd_w_colorram                         	| [$b404: ld   (hl),d]
	move.w	(sp)+,d0
	tst.b	d0                               	| [$b42f: and  a]
	sub.w	d1,d6							| [sbc  hl,bc]
	move.w	#0x0020,d1     	| [$b432: ld   bc,task_address_table_0020]
	clr.b	d0                               	| [$b435: xor  a]
	sub.w	d1,d6							| [sbc  hl,bc]
	movem.w	(sp)+,d1/d2                    	| [$b438: pop  bc]
	addq.w	#1,a3                           	| [$b439: inc  iy]
	subq.b	#1,d1                           	| [$b43b: dec  b]
	jne	l_b3dc                             	| [$b43c: jp   nz,$B3DC]
	rts                                    	| [$b43f: ret]


startup_B469:

	move.b	#0x42,d0                        	| [$b469: ld   a,$42]
	move.b	d0,unknown_CD21                 	| [$b46b: ld   (unknown_CD21),a]
	lea		stack_top_CF00,sp			| ld   sp,stack_top_CF00			| set stack
	jbsr	disable_interrupts_BBE2           	| [$b471: call disable_interrupts_BBE2]
* clear part of RAM
	lea	active_task_bit_table_C000,a0                	| [$b479: ld   hl,active_task_bit_table_C000]
	move.w	#0x0080,d1                      	| [$b47c: ld   bc,$0080] immediate value 128
	jbsr	clear_zone_B2BD                   	| [$b47f: call clear_zone_B2BD]
	jbsr	init_ram_BB41                     	| [$b482: call init_ram_BB41]
	st.b	d0                                	| [$b485: ld   a,$FF]
	move.b	d0,unknown_C02C                 	| [$b487: ld   (unknown_C02C),a]
	jbsr	enable_interrupts_BBE2            	| [$b48a: call enable_interrupts_BBE2]

* this is called by most routines that want to yield control to this mainloop
jump_to_mainloop_B48D:
	lea		stack_top_CF00,sp			| ld   sp,stack_top_CF00			| set stack
	jbsr	enable_interrupts_BBE2            	| [$b490: call enable_interrupts_BBE2]

* main "task" scheduler
* loop until one of the 2 timers/counters is nonzero
* jump at different locations
scheduler_loop_b493:
	lea	unknown_C006,a0                	| [$b493: ld   hl,unknown_C006]
	tst.b	nb_tasks_to_start_C029                 	| [$b496: ld   a,(nb_tasks_to_start_C029)]
											| [$b499: and  a]
	jne	run_a_task_b4a7                             	| [$b49a: jp   nz,$B4A7]

	tst.b	nb_suspended_tasks_C02A                 	| [$b49d: ld   a,(nb_suspended_tasks_C02A)]
											| [$b4a0: and  a]
	jne	resume_a_task_b503                             	| [$b4a1: jp   nz,$B503]
	jra	scheduler_loop_b493                             	| [$b4a4: jp   $B493]

*
* < A0 (HL): task bits structure (always 0xC006)
run_a_task_b4a7:
	clr.b	d0                               	| [$b4a7: xor  a]
	move.b	d0,d3                           	| [$b4a8: ld   d,a]
* check change of bitfield state $C006-$C00B notify bitfield changes
* looks like an event table: each routine can post events by setting
* bits, and the events are acknowledged by bitclears.
* depending on the bits set, we jump to different routines
*
* this is a task scheduler, with stack location change and all!!!
* find a non-zero slot
	move.b	#0x6,d6		| coupling D6 (L) with A0 (HL) to point on 0xC00C
	cmp.b	(a0),d0                          	| [$b4a9: cp   (hl)]
	jne	l_b4b8                             	| [$b4aa: jp   nz,$B4B8]
	addq.w	#1,a0
	addq.b	#1,d6                           	| [$b4ad: inc  l]
	cmp.b	(a0),d0                          	| [$b4ae: cp   (hl)]
	jne	l_b4b8                             	| [$b4af: jp   nz,$B4B8]
	addq.w	#1,a0
	addq.b	#1,d6                           	| [$b4b2: inc  l]
	cmp.b	(a0),d0                          	| [$b4b3: cp   (hl)]
	jne	l_b4b8                             	| [$b4b4: jp   nz,$B4B8]
	* if not found pick the last slot (probably replace last running task if any)
	addq.w	#1,a0
	addq.b	#1,d6                           	| [$b4b7: inc  l]
l_b4b8:
	move.b	d6,d0                           	| [$b4b8: ld   a,l]
	subq.b	#0x06,d0                        	| [$b4b9: sub  $06] if first 0, then sub 06 gives 0
	moveq	#0,d4
	move.b	d0,d4                           	| [$b4bb: ld   e,a]
	rol.b	#3,d4                            	| [$b4bc: rlc  e] times 8
	clr.w	d2                               	| [$b4c2: ld   b,$00]
	move.b	(a0),d2                         	| [$b4c4: ld   c,(hl)]
												| [$b4c5: and  a] clear carry
	add.w	d2,d2                           	| [$b4c6: rl   c] times 2 on 16 bits (bc)
												| [$b4c8: rl   b]
	lea	table_B87D(pc),a2                  	| [$b4ca: ld   ix,table_B87D]
	add.w	d2,a2                            	| [$b4ce: add  ix,bc]

	move.b	(0x00,a2),d1                    	| [$b4d0: ld   b,(ix+$00)]
	move.b	(0x01,a2),d0                    	| [$b4d3: ld   a,(ix+$01)]
	add.b	d4,d0                            	| [$b4d6: add  a,e]
	move.b	d0,d4                           	| [$b4d7: ld   e,a]
	move.b	d0,player_2_attack_flags_C028   	| [$b4d8: ld   (player_2_attack_flags_C028),a]
	move.b	d1,d0                           	| [$b4db: ld   a,b]
	move.b	(a0),d7
	eor.b	d7,d0                            	| [$b4dc: xor  (hl)]
	* kind of zeroes slot, not of what's done here
	move.b	d0,(a0)                         	| [$b4dd: ld   (hl),a]

	add.w	d4,d4                            	| [$b4de: rlc  e]
	add.w	d4,d4                            	| double (long address)
	                               	| [$b4e0: ld   d,$00]
	lea	task_stack_buffer_table_B825(pc),a3      	| [$b4e2: ld   iy,task_stack_buffer_table_B825]
	add.w	d4,a3                            	| [$b4e6: add  iy,de]
	* switch stack pointer according to routine we jump to!!
	* (seems that they've coded a mini-OS for this game!)
	
	move.l	(a3),a7                    	| [$b4e8: ld   l,(iy+$00)]
										| [$b4eb: ld   h,(iy+$01)]
	
									| [$b4ef: ld   hl,nb_tasks_to_start_C029]
	subq.b	#1,nb_tasks_to_start_C029                         	| [$b4f2: dec  (hl)]
	lea		task_address_table_0020,a3                      	| [$b4f3: ld   iy,$0020] 32
	add.w	d4,a3                            	| [$b4f7: add  iy,de]

	move.l	(a3),a0                    	| [$b4f9: ld   l,(iy+$00)]
										| [$b4fc: ld   h,(iy+$01)]
	jbsr	enable_interrupts_BBE2            	| [$b4ff: call enable_interrupts_BBE2]
* called several times at startup
* $5250
* $53D2
* $544F
* $6491
* $7C5D
* $6D5E
* $B099
* $B09C
* $B09F
*
* then called when screen changes

	* starts the task
	jmp	(a0)                               	| [$b502: jp   (hl)]


resume_a_task_b503:
	jbsr	disable_interrupts_BBE2           	| [$b503: call disable_interrupts_BBE2]
	lea	unknown_C00C(pc),a0                	| [$b506: ld   hl,unknown_C00C]
										| [$b509: ld   iy,unknown_C00C]
	tst.l	(a0)                    	| [$b50d: ld   a,(iy+$00)] check for free slots
										| [$b510: or   (iy+$01)]
										| [$b513: or   (iy+$02)]
										| [$b516: or   (iy+$03)]
	jeq	jump_to_mainloop_B48D              	| [$b519: jp   z,jump_to_mainloop_B48D]
	clr.w	d4
	clr.b	d0                               	| [$b51c: xor  a]
	move.b	d0,d4 
	move.b	#0xC,d6			| lsw of original 0xC00C HL
	* compute free task slot?				| [$b51d: ld   d,a]
	cmp.b	(a0),d0                          	| [$b51e: cp   (hl)]
	jne	l_b52d                             	| [$b51f: jp   nz,$B52D]
	addq.w	#1,a0
	addq.w	#1,d6                           	| [$b522: inc  l]
	* check for 1 in task id
	cmp.b	(a0),d0                          	| [$b523: cp   (hl)]
	jne	l_b52d                             	| [$b524: jp   nz,$B52D]
	* check for 2 in task id
	addq.w	#1,a0
	addq.b	#1,d6                           	| [$b527: inc  l]
	cmp.b	(a0),d0                          	| [$b528: cp   (hl)]
	jne	l_b52d                             	| [$b529: jp   nz,$B52D]
	* has to be that slot
	addq.b	#1,d6                           	| [$b52c: inc  l]
l_b52d:
	move.b	d6,d0                           	| [$b52d: ld   a,l]
	sub.b	#0x0C,d0                         	| [$b52e: sub  $0C]
	move.b	d0,d4                           	| [$b530: ld   e,a]
	rol.b	#3,d4                            	| [$b531: rlc  e] * 3 multiply by 8
	tst.b	d0                               	| [$b537: and  a] clear carry?
	clr.w	d1                               	| [$b538: ld   b,$00]
	* get non-zero slot id
	move.b	(a0),d1                         	| [$b53a: ld   c,(hl)]
	add.w	d1,d1                           	| [$b53b: rl   c]
												| [$b53d: rl   b]
	lea	table_B87D(pc),a2                  	| [$b53f: ld   ix,table_B87D]
	add.w	d1,a2                            	| [$b543: add  ix,bc]*
	* get properties
	move.b	(0x00,a2),d1                    	| [$b545: ld   b,(ix+$00)]
	move.b	(0x01,a2),d0                    	| [$b548: ld   a,(ix+$01)]
	add.b	d4,d0                            	| [$b54b: add  a,e]
	move.b	d0,d4                           	| [$b54c: ld   e,a]
	move.b	d0,player_2_attack_flags_C028   	| [$b54d: ld   (player_2_attack_flags_C028),a]
	move.b	d1,d0                           	| [$b550: ld   a,b]
	move.b	(a0),d7
	eor.b	d7,d0                    	      	| [$b551: xor  (hl)]
	* zero/mask out slot
	move.b	d0,(a0)                         	| [$b552: ld   (hl),a]
	add.w	d4,d4                            	| [$b553: rlc  e]
	add.w	d4,d4                            	| double offset (long needs *4)
												| [$b555: ld   d,$00]
	lea	task_struct_table_B7E5(pc),a0                  	| [$b557: ld   hl,table_B7E5]
	add.w	d4,a0                            	| [$b55a: add  hl,de]
	* a0 = task structure
	* rather offset vs bottom than full address, as it would shift
	* task structure offsets. It's complex enough to avoid it!
	lea		stack_bottom_C400,a1
	add.w	(a0),a1
	
	* sets stack for this task 
	* looks like a mini-os with a task
	* scheduler and all!!!
	move.l	a1,sp

	* switch registers, not needed, a0 is still task structure
	* exg	a1,a0                              	| [$b564: ex   de,hl]
										| [$b565: ld   de,$0004] 4
	addq.w	#4,a0                            	| [$b568: add  hl,de]
	* get another task property
	move.b	(a0)+,d1                         	| [$b569: ld   b,(hl)]
									| [$b56a: inc  hl]
	* get another task property (context)
	move.b	(a0),d0                         	| [$b56b: ld   a,(hl)]
	lea	nb_suspended_tasks_C02A(pc),a0                	| [$b56c: ld   hl,nb_suspended_tasks_C02A]
	subq.b	#1,(a0)                         	| [$b56f: dec  (hl)]
	jbsr	enable_interrupts_BBE2            	| [$b570: call enable_interrupts_BBE2]
	* returns with stack properly set: returns to stack & resumes it
	rts                                    	| [$b573: ret]


unsuspend_task_B5CD:
	bsr		osd_break
	nop
	nop
	nop
	nop
	jbsr	disable_interrupts_BBE2           	| [$b5cd: call disable_interrupts_BBE2]
	lea	active_task_bit_table_C000(pc),a0                	| [$b5d0: ld   hl,active_task_bit_table_C000]
	move.b	d0,d2                           	| [$b5d3: ld   c,a]
	moveq	#0,d1                               	| [$b5d4: ld   b,$00]
	moveq	#0,d3                      	| [$b5d6: ld   de,$0000] 0
	and.b	#0x07,d0                         	| [$b5d9: and  $07]
	move.b	d0,d3                           	| [$b5db: ld   e,a]
	move.b	d2,d0                           	| [$b5dc: ld   a,c]
	and.b	#0xF8,d0                         	| [$b5dd: and  $F8]
	roxr.b	#3,d0                           	| [$b5df: rra] * 3
	move.b	d0,d1                           	| [$b5e2: ld   c,a]
	add.w	d1,a0                            	| [$b5e3: add  hl,bc]

	lea	powers_of_2_table_B875(pc),a2      	| [$b5e4: ld   ix,powers_of_2_table_B875]
	add.w	d3,a2                            	| [$b5e8: add  ix,de]

	move.b	(a2),d0                    	| [$b5ea: ld   a,(ix+$00)]
	move.b	d0,d1                           	| [$b5ed: ld   b,a]
	and.b	(a0),d0
	bne.b	0f
	rts                                    	| [$b5ef: ret  z]
0:
	move.b	d1,d0                           	| [$b5f0: ld   a,b]
	move.b	(a0),d7
	eor.b	d7,d0                            	| [$b5f1: xor  (hl)]
	move.b	d0,(a0)                         	| [$b5f2: ld   (hl),a]
	move.w	#0x0006,d3                      	| [$b5f3: ld   de,$0006] 6
	add.w	d3,a0                            	| [$b5f6: add  hl,de]
	move.b	d1,d0                           	| [$b5f7: ld   a,b]
	and.b	(a0),d0
	jeq	l_b607                             	| [$b5f9: jp   z,$B607]
	move.b	d1,d0                           	| [$b5fc: ld   a,b]
	move.b	(a0),d7
	eor.b	d7,d0                          	| [$b5fd: xor  (hl)]
	move.b	d0,(a0)                         	| [$b5fe: ld   (hl),a]
	lea	nb_tasks_to_start_C029(pc),a0      	| [$b5ff: ld   hl,nb_tasks_to_start_C029]
	subq.b	#1,(a0)                         	| [$b602: dec  (hl)]
	jbsr	enable_interrupts_BBE2            	| [$b603: call enable_interrupts_BBE2]
	rts                                    	| [$b606: ret]

l_b607:
	add.w	d3,a0                            	| [$b607: add  hl,de]
	move.b	d1,d0                           	| [$b608: ld   a,b]
	and.b	(a0),d0
	jeq	l_b618                             	| [$b60a: jp   z,$B618]
	move.b	d1,d0                           	| [$b60d: ld   a,b]
	move.b	(a0),d7
	eor.b	d7,d0                            	| [$b5fd: xor  (hl)]
	move.b	d0,(a0)                         	| [$b60f: ld   (hl),a]
	lea	nb_suspended_tasks_C02A(pc),a0     	| [$b610: ld   hl,nb_suspended_tasks_C02A]
	subq.b	#1,(a0)                         	| [$b613: dec  (hl)]
	jbsr	enable_interrupts_BBE2            	| [$b614: call enable_interrupts_BBE2]
	rts                                    	| [$b617: ret]

l_b618:
	add.w	d3,a0                            	| [$b618: add  hl,de]
	move.b	d1,d0                           	| [$b619: ld   a,b]
	move.b	(a0),d7
	eor.b	d7,d0                            	| [$b60e: xor  (hl)]
	move.b	d0,(a0)                         	| [$b61b: ld   (hl),a]
	jbsr	enable_interrupts_BBE2            	| [$b61c: call enable_interrupts_BBE2]
	rts                                    	| [$b61f: ret]

* < A: task index to schedule for start
* changes $C000-$C005 (bitfield 6*8 = 48 bits)
* returns changed bits in $C006-$C00B
* returns 0 if something changed, $FF otherwise
schedule_task_to_start_B620:
	jbsr	disable_interrupts_BBE2           	| [$b620: call disable_interrupts_BBE2]
	lea	active_task_bit_table_C000,a0                	| [$b623: ld   hl,active_task_bit_table_C000]
	move.b	d0,d2                           	| [$b626: ld   c,a]
	clr.w	d1                               	| [$b627: ld   b,$00]
	moveq	#0,d3                      	| [$b629: ld   de,$0000] 0
	and.b	#0x07,d0                         	| [$b62c: and  $07]
	move.b	d0,d3                           	| [$b62e: ld   e,a] A & 7 in E
	move.b	d2,d0                           	| [$b62f: ld   a,c] restore original A
	and.b	#0xF8,d0                         	| [$b630: and  $F8] mask it to get upper part (align on 8)
	roxr.b	#3,d0                           	| [$b632: rra] * 3 divide by 8
	move.b	d0,d1                           	| [$b635: ld   c,a]
	add.w	d1,a0                            	| [$b636: add  hl,bc]
	lea	powers_of_2_table_B875(pc),a2      	| [$b637: ld   ix,powers_of_2_table_B875]
	add.w	d3,a2                            	| [$b63b: add  ix,de]

* get proper power of 2 value in A (single bit value)
	move.b	(a2),d0                    	| [$b63d: ld   a,(ix+$00)]
	move.b	d0,d4                           	| [$b640: ld   e,a]
	and.b	(a0),d0							| [and  (hl)]
	jne	l_b658                             	| [$b642: jp   nz,$B658]
	move.b	d4,d0                           	| [$b645: ld   a,e]
	or.b	(a0),d0                           	| [$b646: or   (hl)]
	move.b	d0,(a0)                         	| [$b647: ld   (hl),a]
	moveq	#0x0006,d1                      	| [$b648: ld   bc,$0006] 6
        * next bitfield
	add.w	d1,a0                            	| [$b64b: add  hl,bc]
	move.b	d4,d0                           	| [$b64c: ld   a,e]
	or.b	(a0),d0                           	| [$b64d: or   (hl)]
	move.b	d0,(a0)                         	| [$b64e: ld   (hl),a]
	lea	nb_tasks_to_start_C029,a0      	| [$b64f: ld   hl,nb_tasks_to_start_C029]
	addq.b	#1,(a0)                         	| [$b652: inc  (hl)] increment timer
	clr.b	d0                               	| [$b653: xor  a]
	jbsr	enable_interrupts_BBE2            	| [$b654: call enable_interrupts_BBE2]
	rts                                    	| [$b657: ret]
l_b658:
	st.b	d0                                	| [$b658: ld   a,$FF]
	jbsr	enable_interrupts_BBE2            	| [$b65a: call enable_interrupts_BBE2]
	rts                                    	| [$b65d: ret]

* < a: time to suspend??
* this can be slower or faster if a computer is playing
* depending on the difficulty level
suspend_task_B65E:
	bsr		osd_break
	nop
	nop
	jbsr	disable_interrupts_BBE2           	| [$b65e: call disable_interrupts_BBE2]
	move.w	d0,-(sp)                        	| [$b661: push af]
	move.b	player_2_attack_flags_C028,d0   	| [$b662: ld   a,(player_2_attack_flags_C028)]
	lea	unknown_C012,a0                	| [$b665: ld   hl,unknown_C012]
	move.b	d0,d2                           	| [$b668: ld   c,a]
	clr.w	d1                               	| [$b669: ld   b,$00]
	move.w	#0x0000,d3                      	| [$b66b: ld   de,$0000] 0
	and.b	#0x07,d0                         	| [$b66e: and  $07]
	move.b	d0,d3                           	| [$b670: ld   e,a]
	move.b	d2,d0                           	| [$b671: ld   a,c]
	and.b	#0xF8,d0                         	| [$b672: and  $F8]
	roxr.b	#3,d0                           	| [$b674: rra] * 3
	move.b	d0,d1                           	| [$b677: ld   c,a]
	add.w	d1,a0                            	| [$b678: add  hl,bc]
	lea	powers_of_2_table_B875(pc),a2      	| [$b679: ld   ix,powers_of_2_table_B875]
	add.w	d3,a2                            	| [$b67d: add  ix,de]
	move.b	(a2),d0                    	| [$b67f: ld   a,(ix+$00)]
	or.b	(a0),d0                           	| [$b682: or   (hl)]
	move.b	d0,(a0)                         	| [$b683: ld   (hl),a]
	move.b	player_2_attack_flags_C028,d0   	| [$b684: ld   a,(player_2_attack_flags_C028)]
	lea	task_struct_C100,a3                	| [$b687: ld   iy,task_struct_C100]
	move.b	d0,d1                           	| [$b68b: ld   b,a]
	clr.b	d2                               	| [$b68c: ld   c,$00]
	tst.b	d0                               	| [$b68e: and  a]
	roxr.b	#1,d1                           	| [$b68f: rr   b]
	roxr.b	#1,d2                           	| [$b691: rr   c]
	roxr.b	#1,d1                           	| [$b693: rr   b]
	roxr.b	#1,d2                           	| [$b695: rr   c]
	roxr.b	#1,d1                           	| [$b697: rr   b]
	roxr.b	#1,d2                           	| [$b699: rr   c]
	lsl.w	#8,d1
	move.b	d2,d1
	add.w	d1,a3                            	| [$b69b: add  iy,bc]
	move.w	(sp)+,d0                        	| [$b69d: pop  af]
* writes in player struct + 2: number of frames to wait until next frame
	move.b	d0,(0x02,a3)                    	| [$b69e: ld   (iy+$02),a]
	* get current stack (rather stack offset so we fit in 16 bits) 
	* to store it in the task structure
	                      	                   | [$b6a1: ld   hl,$0000] 0
	move.l	sp,d0                            	| [$b6a4: add  hl,sp]
	sub.l	#stack_bottom_C400,d0
	move.w	d0,(a3)           | [$b6a5: ld   (iy+$00),l]
	                          | [$b6a8: ld   (iy+$01),h]

	
	jra	jump_to_mainloop_B48D              	| [$b6ab: jp   jump_to_mainloop_B48D]

* seems to suspend a task but also make up for that and unsuspend...
task_manipulation_B6AE:
	jbsr	disable_interrupts_BBE2           	| [$b6ae: call disable_interrupts_BBE2]
	movem.w	d1/d2,-(sp)                    	| [$b6b1: push bc]
	move.w	d0,-(sp)                        	| [$b6b2: push af]
	lea	active_task_bit_table_C000(pc),a0                	| [$b6b3: ld   hl,active_task_bit_table_C000]
	move.b	d0,d2                           	| [$b6b6: ld   c,a]
	clr.w	d1                               	| [$b6b7: ld   b,$00]
	moveq	#0,d3                      	| [$b6b9: ld   de,$0000] 0
	and.b	#0x07,d0                         	| [$b6bc: and  $07]
	move.b	d0,d3                           	| [$b6be: ld   e,a]
	move.b	d2,d0                           	| [$b6bf: ld   a,c]
	and.b	#0xF8,d0                         	| [$b6c0: and  $F8]
	roxr.b	#3,d0                           	| [$b6c2: rra] * 3
	move.b	d0,d1                           	| [$b6c5: ld   c,a]
	add.w	d1,a0                            	| [$b6c6: add  hl,bc]

	move.l	a0,-(sp)                        	| [$b6c7: push hl]
	lea	powers_of_2_table_B875(pc),a2      	| [$b6c8: ld   ix,powers_of_2_table_B875]
	add.w	d3,a2                            	| [$b6cc: add  ix,de]

	move.b	(a2),d0                    	| [$b6ce: ld   a,(ix+$00)]
	move.b	d0,d1                           	| [$b6d1: ld   b,a]
	and.b	(a0),d0							| [and  (hl)]
	jeq	l_b726                             	| [$b6d3: jp   z,$B726]
											| [$b6d6: ld   de,$0006] 6
	addq.w	#6,a0                            	| [$b6d9: add  hl,de]
	move.b	d1,d0                           	| [$b6da: ld   a,b]
	and.b	(a0),d0							| [and  (hl)]
	jne	l_b726                             	| [$b6dc: jp   nz,$B726]
	move.b	d1,d0                           	| [$b6df: ld   a,b]
												| [$b6e0: ld   de,$000C] 12
	add.w	#0xc,a0                            	| [$b6e3: add  hl,de]

	move.b	d1,d0                           	| [$b6e4: ld   a,b]
	not.b	d0                               	| [$b6e5: cpl]
	and.b	(a0),d0							| [and  (hl)]
	move.b	d0,(a0)                         	| [$b6e7: ld   (hl),a]
	* get pushed hl value in de
	move.l	(sp)+,a1                        	| [$b6e8: pop  de]
	move.w	#0x000C,a0                      	| [$b6e9: ld   hl,$000C]
	* and add 12 to it
	add.l	a1,a0                            	| [$b6ec: add  hl,de]
	move.b	d1,d0                           	| [$b6ed: ld   a,b]
	and.b	(a0),d0							| [and  (hl)]
	jeq	l_b6f9                             	| [$b6ef: jp   z,$B6F9]
	* if condition met, one less task is suspended
	lea	nb_suspended_tasks_C02A(pc),a3     	| [$b6f2: ld   iy,nb_suspended_tasks_C02A]
	subq.b	#1,(0x00,a3)                    	| [$b6f6: dec  (iy+$00)]
l_b6f9:
	move.b	d1,d0                           	| [$b6f9: ld   a,b]
	or.b	(a0),d0                           	| [$b6fa: or   (hl)]
	move.b	d0,(a0)                         	| [$b6fb: ld   (hl),a]
	move.w	(sp)+,d0                        	| [$b6fc: pop  af]
	lea	task_struct_C100(pc),a3                	| [$b6fd: ld   iy,task_struct_C100]
	move.b	d0,d1                           	| [$b701: ld   b,a]
	clr.b	d2                               	| [$b702: ld   c,$00]
	tst.b	d0                               	| [$b704: and  a]
	roxr.b	#1,d1                           	| [$b705: rr   b]
	roxr.b	#1,d2                           	| [$b707: rr   c]
	roxr.b	#1,d1                           	| [$b709: rr   b]
	roxr.b	#1,d2                           	| [$b70b: rr   c]
	roxr.b	#1,d1                           	| [$b70d: rr   b]
	roxr.b	#1,d2                           	| [$b70f: rr   c]
	lsl.w	#8,d1
	move.b	d2,d1
	add.w	d1,a3                            	| [$b711: add  iy,bc]

	move.b	player_2_attack_flags_C028,d0   	| [$b713: ld   a,(player_2_attack_flags_C028)]
	move.b	d0,(0x05,a3)                    	| [$b716: ld   (iy+$05),a]
	movem.w	(sp)+,d1/d2                    	| [$b719: pop  bc]
	move.b	d1,(0x06,a3)                    	| [$b71a: ld   (iy+$06),b]
	lea	nb_suspended_tasks_C02A(pc),a0     	| [$b71d: ld   hl,nb_suspended_tasks_C02A]
	addq.b	#1,(a0)                         	| [$b720: inc  (hl)]
	clr.b	d0                               	| [$b721: xor  a]
	jbsr	enable_interrupts_BBE2            	| [$b722: call enable_interrupts_BBE2]
	rts           

l_b726:
	move.l	(sp)+,a0                        	| [$b726: pop  hl]
	move.w	(sp)+,d0                        	| [$b727: pop  af]
	movem.w	(sp)+,d1/d2                    	| [$b728: pop  bc]
	st.b	d0                                	| [$b729: ld   a,$FF]
	jbsr	enable_interrupts_BBE2            	| [$b72b: call enable_interrupts_BBE2]
	rts                                    	| [$b72e: ret]
	
task_struct_table_B7E5:
	.long	task_struct_C100                           	|  $b7e5
	.long	task_struct_C120                           	|  $b7e7
	.long	task_struct_C140                           	|  $b7e9
	.long	task_struct_C160                           	|  $b7eb
	.long	task_struct_C180                           	|  $b7ed
	.long	task_struct_C1A0                           	|  $b7ef
	.long	task_struct_C1C0                           	|  $b7f1
	.long	task_struct_C1E0                           	|  $b7f3
	.long	task_struct_C200                           	|  $b7f5
	.long	task_struct_C220                           	|  $b7f7
	.long	task_struct_C240                           	|  $b7f9
	.long	task_struct_C260                           	|  $b7fb
	.long	task_struct_C280                           	|  $b7fd
	.long	task_struct_C2A0                           	|  $b7ff
	.long	task_struct_C2C0                           	|  $b801
	.long	task_struct_C2E0                           	|  $b803
	.long	task_struct_C300                           	|  $b805
	.long	task_struct_C320                           	|  $b807
	.long	task_struct_C340                           	|  $b809
	.long	task_struct_C360                           	|  $b80b
	.long	task_struct_C380                           	|  $b80d
	.long	task_struct_C3A0                           	|  $b80f
	.long	task_struct_C3C0                           	|  $b811
	.long	task_struct_C3E0                           	|  $b813
	.long	task_struct_C400                           	|  $b815
	* this is probably not reached, and a mistake
	* as this overlaps the stack buffers
	* let it crash loudly if accessed!!!
	.long	-1   | task_struct_C420                           	|  $b817
	.long	-1   | task_struct_C440                           	|  $b819
	.long	-1   | task_struct_C460                           	|  $b81b
	.long	-1   | task_struct_C480                           	|  $b81d
	.long	-1   | task_struct_C4A0                           	|  $b81f
	.long	-1   | task_struct_C4C0                           	|  $b821
	.long	-1   | task_struct_C4E0                           	|  $b823
task_stack_buffer_table_B825:
	.long	stack_buffer_C420                           	|  $b825
	.long	stack_buffer_C440                           	|  $b827
	.long	stack_buffer_C460                           	|  $b829
	.long	stack_buffer_C480                           	|  $b82b
	.long	stack_buffer_C4A0                           	|  $b82d
	.long	stack_buffer_C4C0                           	|  $b82f
	.long	stack_buffer_C4E0                           	|  $b831
	.long	stack_buffer_C500                           	|  $b833
	.long	stack_buffer_C520                           	|  $b835
	.long	stack_buffer_C540                           	|  $b837
	.long	stack_buffer_C560                           	|  $b839
	.long	stack_buffer_C580                           	|  $b83b
	.long	stack_buffer_C5A0                           	|  $b83d
	.long	stack_buffer_C5C0                           	|  $b83f
	.long	stack_buffer_C5E0                           	|  $b841
	.long	stack_buffer_C600                           	|  $b843
	.long	stack_buffer_C620                           	|  $b845
	.long	stack_buffer_C640                           	|  $b847
	.long	stack_buffer_C660                           	|  $b849
	.long	stack_buffer_C680                           	|  $b84b
	.long	stack_buffer_C6A0                           	|  $b84d
	.long	stack_buffer_C6C0                           	|  $b84f
	.long	stack_buffer_C6E0                           	|  $b851
	.long	stack_buffer_C700                           	|  $b853
	.long	-1   | stack_buffer_C720                           	|  $b855
	.long	-1   | stack_buffer_C740                           	|  $b857
	.long	-1   | stack_buffer_C760                           	|  $b859
	.long	-1   | stack_buffer_C780                           	|  $b85b
	.long	-1   | stack_buffer_C7A0                           	|  $b85d
	.long	-1   | stack_buffer_C7C0                           	|  $b85f
	.long	-1   | stack_buffer_C7E0                           	|  $b861
	.long	-1   | stack_buffer_C800                           	|  $b863
	.long	active_task_bit_table_C000                           	|  $b865
	.long	unknown_C008                           	|  $b867
	.long	unknown_C010                           	|  $b869
	.long	unknown_C018                           	|  $b86b
	.long	unknown_C020                           	|  $b86d
	.long	player_2_attack_flags_C028                           	|  $b86f
	.long	dip_switches_copy_C030                          	|  $b871
	.long	unknown_C038                           	|  $b873


powers_of_2_table_B875:
	dc.b	0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80 | $b875
table_B87D:
	dc.b	0x00,0x00,0x01,0x00,0x02,0x01,0x01,0x00 | $b87d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b885
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $b88d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b895
	dc.b	0x10,0x04,0x01,0x00,0x02,0x01,0x01,0x00 | $b89d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b8a5
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $b8ad
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b8b5
	dc.b	0x20,0x05,0x01,0x00,0x02,0x01,0x01,0x00 | $b8bd
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b8c5
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $b8cd
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b8d5
	dc.b	0x10,0x04,0x01,0x00,0x02,0x01,0x01,0x00 | $b8dd
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b8e5
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $b8ed
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b8f5
	dc.b	0x40,0x06,0x01,0x00,0x02,0x01,0x01,0x00 | $b8fd
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b905
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $b90d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b915
	dc.b	0x10,0x04,0x01,0x00,0x02,0x01,0x01,0x00 | $b91d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b925
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $b92d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b935
	dc.b	0x20,0x05,0x01,0x00,0x02,0x01,0x01,0x00 | $b93d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b945
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $b94d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b955
	dc.b	0x10,0x04,0x01,0x00,0x02,0x01,0x01,0x00 | $b95d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b965
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $b96d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b975
	dc.b	0x80,0x07,0x01,0x00,0x02,0x01,0x01,0x00 | $b97d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b985
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $b98d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b995
	dc.b	0x10,0x04,0x01,0x00,0x02,0x01,0x01,0x00 | $b99d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b9a5
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $b9ad
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b9b5
	dc.b	0x20,0x05,0x01,0x00,0x02,0x01,0x01,0x00 | $b9bd
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b9c5
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $b9cd
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b9d5
	dc.b	0x10,0x04,0x01,0x00,0x02,0x01,0x01,0x00 | $b9dd
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b9e5
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $b9ed
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b9f5
	dc.b	0x40,0x06,0x01,0x00,0x02,0x01,0x01,0x00 | $b9fd
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $ba05
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $ba0d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $ba15
	dc.b	0x10,0x04,0x01,0x00,0x02,0x01,0x01,0x00 | $ba1d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $ba25
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $ba2d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $ba35
	dc.b	0x20,0x05,0x01,0x00,0x02,0x01,0x01,0x00 | $ba3d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $ba45
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $ba4d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $ba55
	dc.b	0x10,0x04,0x01,0x00,0x02,0x01,0x01,0x00 | $ba5d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $ba65
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $ba6d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $ba75

init_ram_BB41:
* clear video ram
	*lea	l_D000(pc),a0                      	| [$bb44: ld   hl,$D000]
	*lea	l_1000(pc),a4                      	| [$bb47: ld   bc,$1000] immediate value
	*jbsr	clear_zone_B2BD                   	| [$bb4a: call clear_zone_B2BD]
* clear ram
	*lea	active_task_bit_table_C000(pc),a0                	| [$bb4d: ld   hl,active_task_bit_table_C000]
	*move.w	#0x1000,d1                      	| [$bb50: ld   bc,$1000] immediate value
	*jbsr	clear_zone_B2BD                   	| [$bb53: call clear_zone_B2BD]
* init ram with some startup values
	jbsr	init_C040_F6E5                    	| [$bb57: call init_C040_F6E5]
	move.b	#0x02,d0                        	| [$bb5a: ld   a,$02]
	move.b	d0,unknown_C0C0                 	| [$bb5c: ld   (unknown_C0C0),a]
	jbsr	get_dip_switches_BB92             	| [$bb5f: call get_dip_switches_BB92]
	move.b	d0,dip_switches_copy_C030       	| [$bb62: ld   (dip_switches_copy_C030),a]
	clr.b	d0                               	| [$bb65: xor  a]
	jbsr	schedule_task_to_start_B620                 	| [$bb66: call schedule_task_to_start_B620]
	move.b	#0x80,d0                        	| [$bb69: ld   a,$80]
	jbsr	stop_sound_BBDF                   	| [$bb6b: call stop_sound_BBDF]
	rts                                    	| [$bb6e: ret]

set_normal_screen_bb72:
	rts

* read system port
check_coin_ports_BB82:
	movem.w	d1/d2,-(sp)                    	| [$bb82: push bc]                       	| [$bb82: push bc]
*in   a,($80)
	moveq	#0,d0		| temp!!
	not.b	d0                               	| [$bb85: cpl]
* only 4 first bits are used
*	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
*	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
*	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START1 )
*	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_START2 )
	and.b	#0x0F,d0                         	| [$bb86: and  $0F]
	move.b	d0,d1                           	| [$bb88: ld   b,a]
	ror.b	#2,d0                            	| [$bb89: rrca] * 2
	and.b	#0xC0,d0                         	| [$bb8b: and  $C0] coin inserted bits
	or.b	d1,d0                             	| [$bb8d: or   b]
	and.b	#0xCC,d0                         	| [$bb8e: and  $CC]
	movem.w	(sp)+,d1/d2                    	| [$bb90: pop  bc]
	rts                                    	| [$bb91: ret]

get_dip_switches_BB92:
	moveq	#0,d0
	*in   a,($C0)
	not.b	d0                               	| [$bb94: cpl] invert bits (active low logic)
	rts                                    	| [$bb95: ret]

disable_interrupts_BBE2:
	jbsr		osd_disable_vblank_interrupt
	rts
	
enable_interrupts_BBE2:
	jbsr		osd_enable_vblank_interrupt
	rts

stop_sound_BBDF:
	jra	osd_sound_stop	| [$bbe1: ret]


* copy contents of ROM in $C040
init_C040_F6E5:
	move.w	#0x006C,d1                      	| [$f6e5: ld   bc,$006C] 108
	lea	table_F6F1(pc),a0                  	| [$f6e8: ld   hl,table_F6F1]
	lea	unknown_C040,a1                	| [$f6eb: ld   de,unknown_C040]
	jbsr	ldir                              	| [$f6ee: ldir]
	rts                                    	| [$f6f0: ret]
table_F6F1:
	dc.b	0x02,0x00,0x00,0x00,0x00,0x00,0x13,0xb0 | table_F6F1
	dc.b	0x1e,0xb0,0x0c,0xb0,0x14,0xb0,0x22,0xb0 | $f6f9
	dc.b	0x00,0x03,0x01,0x80,0x00,0x00,0x00,0x00 | $f701
	dc.b	0x16,0xb0,0x0a,0xb0,0x1b,0xb0,0x22,0xb0 | $f709
	dc.b	0x3c,0xb0,0x00,0x02,0x01,0x60,0x00,0x00 | $f711
	dc.b	0x00,0x00,0x14,0xb0,0x1e,0xb0,0x17,0xb0 | $f719
	dc.b	0x1d,0xb0,0x0a,0xb0,0x00,0x02,0x01,0x40 | $f721
	dc.b	0x00,0x00,0x00,0x00,0x1b,0xb0,0x0e,0xb0 | $f729
	dc.b	0x12,0xb0,0x14,0xb0,0x18,0xb0,0x00,0x01 | $f731
	dc.b	0x01,0x20,0x00,0x00,0x00,0x00,0x13,0xb0 | $f739
	dc.b	0x18,0xb0,0x17,0xb0,0x22,0xb0,0x3c,0xb0 | $f741
	dc.b	0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00 | $f749
	dc.b	0x2f,0xb0,0x2f,0xb0,0x2f,0xb0,0x2f,0xb0 | $f751
	dc.b	0x2f,0xb0,0x00,0x01 | $f759
	

* < A0: source (HL)
* < A1: destination (DE)
* < D1: length (16 bit)
ldir:
    subq.w    #1,d1
0:
    move.b    (a0)+,(a1)+
    dbf        d1,0b
    clr.w    d1
    rts
