
*
* 68k transcode by JOTD in 2023 using (https://github.com/jotd666/amiga68ktools)
  
* register conventions (imposed by z80268k mostly) are as follows:
*
* A: D0
* B: D1
* C: D2
* BC: manual
* D: D3
* E: D4
* DE: A1 or D3
* H: D5
* L: D6
* HL: A0 or D6 (video addresses)
* carry: manual, using D7 (push/pop af has no portable equivalent as SR is privileged on 68020+)
*
*
* Karate Champ VS 2. Reverse-engineering attempt by JOTD, focusing on 2 points:
* - CPU A.I.
* - animations
*
* CF02: time when entering highscore (BCD)
*
* current level info is propagated at 3 locations which mean different things:
*
* C0DC: number (1ST, 2ND...)
* C900: map index (picture, girl)
* C910: skill level (see below)
* background_and_state_bits_C911: background+state bits

* C028: attack flags (red player/red cpu), can be 08,09,0A TODO figure out when????

* nb_credits_minus_one_C024: 0 when no credit, then if coin is inserted, set to 1, then
* immediately decreased, while showing "press 1P button" screen

* C910: skill level / speed of computer
* 0: slow => 12: super fast. $10 seems a threshold
* aggressivity is also increased
* increasing skill level dynamically works: computer goes super ninja)
*
* C556-59: 4 bytes looks like counters. When move is completed all 4 values are 8

* C02D
* players_type_human_or_cpu_flags_C02D: 05 1 player vs CPU, 0F 2 players. Changing dynamically works too!

* note: there are 4 structures C200, C220, C240, C260... there are copies of data for instance C229/C22A are copied
* to C269/C26A. Not sure of everything that's written below in terms of addresses...
* C200/C240: player 1 structures
* C220/C260: player 1 structures


* C220: another structure, A.I. related, probably sharing both parties characteristics
* TODO: figure out more values from that structure, specially:
* +07/+08: frame id/pointer on frame structure of own player, used as input of check_hl_in_ix_list_B009 by A.I
*  so the CPU can recognize the moves
* +09 white player x ($20 min $DF max)
* +0A: current move index (at least during practice)
* +0B/+0C: frame id, like 07/08 for opponent player. Note: bit 8 of C22C set: opponent facing right, maybe
*     only important for frame display
* +0D opponent player x
* +0E oppnent move index
* +0F ($C20F): player logical distance, often addressed as  bit  7,(iy+$0f)
* distance seems to be computed from the backs of the players
* bit 7 set => means current player is turning his back to opponent)
* then
* 0: back 2 back distance > 0x70
* 1-4: opponent faces current player (which can turn its back to opponent, see bit 7)
* 1: back 2 back distance > 0x58
* 2: back 2 back distance > 0x40
* 3: back 2 back distance > 0x28
* 4: back 2 back distance > 0x10
* 5-7: opponent turns back to current player (which can turn its back to opponent, see bit 7)
* 5: back 2 back distance > 0x60
* 6: back 2 back distance > 0x30
* 7: back 2 back distance > 0x18
* 8: smaller distance (<= 0x10/0x18) (at least one player must turn his back)
*
* there's a $10 (8 ?) offset depending on facing

* C240: player 1 structure
* +2: 0 when not animated, else number of ticks to stay in the current animation frame
* +7,8: animation related. Bit 7 of C248: facing direction
* C249 (+$9): player 1 x coord. Ranges $20 (32 top left) to $DF (223 right), starts at 0x30
* C24A (+$A): player 1 y coord. $E0 when fighting. Practice:
* C24B (+$B): player 1 current move: codes below
* C24C (+$C): rough distance 0-4
* 0: far
* 1: intermediate, facing other player  (regardless of other player facing direction)
* 2: very close, facing other player   ("")
* 3: intermediate, turning back to other player  ("")
* 4: very close, turning back to other player    ("")
*
*
* C260: player 2 structure
* C269 (+$9): x coord. starts at 0xD0
* C26A (+$A): y coord. $E0 when fighting. Practice: $90
* C26B: player 2 current move (see codes below). Also set during "practice"
* C26C: player 2 rough distance to player 1 0 (same as C24C for second player)
*
* for instance if white is on the left (facing right) and red is on the right, close (facing right)
* the value of
* C24C is: 02
* C26C is: 04
*
* changing C249 immediately reflects on player 1 (white) moving x wise
* changing C269 immediately reflects on player 2 (red) moving x wise
* players can't be exactly at the same position. At least $10 distance is required
* (setting values too close to each other results in game correcting them, same for min/max)
*

* the codes don't match exact moves, but rather the attack type
* there is often only one attack type (back kick) but sometimes there are
* several: example with front kick and weak reverse punch, that only differ
* by attack distance
*
* values marked with "**" trigger the relevant moves only when injecting
* them by setting a at AB56. Injecting 07 doesn't make CPU turn around, but
* does something else.
*
* also attacks can be triggered in other places

* 0x00: not moving, guard
* 0x01: moving back
* 0x02: moving forward
* 0x03: pre-jump (jump to avoid low blow?)
* 0x04: crouch
* 0x05: back kick
* 0x06: ** back kick
* 0x07: turn around (only CPU can do that without using an aborted back jump/round kick)
* 0x08: jumping back kick
* 0x09: foot sweep (back)
* 0x0A: front kick (can also be small reverse punch at short range apparently)
* 0x0B: back round kick
* 0x0C: lunge punch (medium 200-400 forward+forward)
* 0x0D: jumping side kick
* 0x0E: ** foot sweep (front)
* 0x0F: round kick
* 0x10: lunge punch (high 300-600 rear+up)
* 0x11: lunge punch (high 500-1000 forward+up)
* 0x12: rear sommersault
* 0x13: reverse punch (crouch 400-800)
* 0x14: low kick
* 0x15: ** low kick
* 0x16: ** low kick
* 0x17: front sommersault
* 0x18: foot sweep (front)

* difficulty level only has an effect before "CMP" level number 16
* in CMP (champ) level and stage 16 (brige CMP if I'm not mistaken),
* difficulty dip switches are ignored, game is just super fast
* and super hard
*
*A.I: how computer maintains its moves ?
*
* - attack moves: once the attack went through (and failed), depending
*   on the skill level, computer waits a while with the move frozen
*   (including jumping moves, which looks a bit weird). In champion level
*   from level 16, there is no wait at all.
* - blocking moves: maintaned as long as the opponent is performing
*   an attack move with a matching attack height

* I should get more info about player_2_attack_flags_C028 what does the values mean (09,0A...)
* probably related to animation frames not to A.I. so less interesting

* VS Version Info:
* ---------------
* Memory Map:
* Main CPU
* 0000-bfff ROM (encrypted)
* c000-cfff RAM
* d000-d3ff char videoram
* d400-d7ff color videoram
* d800-d8ff sprites
* e000-ffff ROM (encrypted)

* IO Ports:
* Main CPU
* INPUT  00 = Player 1 Controls - ( ACTIVE LOW )
* INPUT  40 = Player 2 Controls - ( ACTIVE LOW )
* INPUT  80 = Coins and Start Buttons - ( ACTIVE LOW )
* INPUT  C0 = Dip Switches - ( ACTIVE LOW )
* OUTPUT 00 = Screen Flip
* OUTPUT 01 = CPU Control
*                 bit 0 = external nmi enable
* OUTPUT 02 = Sound Reset
* OUTPUT 40 = Sound latch write
*
* Sound CPU
* INPUT  01 = Sound latch read
* OUTPUT 00 = AY8910 #1 data write
* OUTPUT 01 = AY8910 #1 control write
* OUTPUT 02 = AY8910 #2 data write
* OUTPUT 03 = AY8910 #2 control write
* OUTPUT 04 = MSM5205 write
* OUTPUT 05 = CPU Control
*                 bit 0 = MSM5205 trigger
*                 bit 1 = external nmi enable


    .global karate_champ_irq
    .global karate_champ_reset

	.ifdef	__amiga__
	.include "karate_champ_ram.68k"
	.align	2
	.endif

karate_champ_irq:
	rts
	
karate_champ_reset:
	* default: 1 update/irq call
	* we need 60 updates / second so on amiga PAL
	* we need to set this variable to 2 once out of 5 calls
	move.b	#1,vb_ticks_count
	lea		stack_top_CF00,sp
l_0000:
	jra	startup_B045                       	| [jp   startup_B045]
	
* routines called by the main scheduler at B502
task_address_table_0020:
	.long	task_5250                           	|  $0020
	.long	task_53d2                           	|  $0022
	.long	task_544f                           	|  $0024
	.long	task_6491                           	|  $0026
	.long	task_6529                           	|  $0028
	.long	task_7c5d                           	|  $002a
	.long	task_6f89                           	|  $002c
	.long	task_6622                           	|  $002e
	.long	task_755b                           	|  $0030
	.long	task_7657                           	|  $0032
	.long	task_3a9c                           	|  $0034
	.long	task_3a9c                           	|  $0036
	.long	task_illegal
	.long	task_illegal
	.long	task_illegal
	.long	task_6d5e                           	|  $003e
	.long	task_47d6                           	|  $0040
	.long	task_47d6                           	|  $0042
	.long	task_47d6                           	|  $0044
	.long	task_47d6                           	|  $0046
	.long	task_50f2                           	|  $0048
	.long	task_b099                           	|  $004a
	.long	task_b09c                           	|  $004c
	.long	task_b09f                           	|  $004e

task_illegal:
	illegal
	nop
	
task_53d2:   
	bsr	osd_break
	nop
	nop
	
task_544f:   
task_6491:   
task_6529:   
task_7c5d:   
task_6f89:   
task_6622:   
task_755b:   
task_7657:   
task_3a9c:
task_6d5e:   
task_47d6:   
task_50f2:   
task_b099:   
task_b09c:   
task_b09f:
	illegal

task_5250:
	clr.b	d0                               	| [$5250: ld   a,$00]
	lea	map_index_C900,a2              	| [$5252: ld   ix,map_index_C900]
	move.b	d0,(0x00,a2)                    	| [$5256: ld   (ix+$00),a]
	lea	table_53CC(pc),a0                  	| [$5259: ld   hl,table_53CC]
	move.b	d6,(0x02,a2)                    	| [$525c: ld   (ix+$02),l]
	move.b	d5,(0x03,a2)                    	| [$525f: ld   (ix+$03),h]
	move.b	(a0),d0                         	| [$5262: ld   a,(hl)]
	move.b	d0,(0x01,a2)                    	| [$5263: ld   (ix+$01),a]
l_5266:
	move.b	players_type_human_or_cpu_flags_C02D,d0	| [$5266: ld   a,(players_type_human_or_cpu_flags_C02D)]
	move.b	d0,unknown_C032                 	| [$5269: ld   (unknown_C032),a]
	move.b	#0x01,d0                        	| [$526c: ld   a,$01]
	jbsr	schedule_task_to_start_B057                 	| [$526e: call schedule_task_to_start_B057]
	tst.b	d0                               	| [$5271: and  a]
	beq.b	0f
	jbsr	display_error_text_B075           	| [$5272: call nz,display_error_text_B075]
0:
	move.b	#0x80,d0                        	| [$5275: ld   a,$80]
	jbsr	stop_sound_b0ae                            	| [$5277: call $B0AE]
	move.b	dip_switches_copy_C030,d0       	| [$527a: ld   a,(dip_switches_copy_C030)]
	btst.b	#7,d0                           	| [$527d: bit  7,a] free play bit
	jeq	l_5287                             	| [$527f: jp   z,$5287]
	move.b	#0x03,d0                        	| [$5282: ld   a,$03]
	move.b	d0,nb_credits_minus_one_C024    	| [$5284: ld   (nb_credits_minus_one_C024),a]
l_5287:
	clr.b	d0                               	| [$5287: ld   a,$00]
	jbsr	suspend_task_B05A            	| [$5289: call suspend_task_B05A]
	jbsr	set_normal_screen_b060                            	| [$528c: call $B060]
	move.b	#0x01,d0                        	| [$528f: ld   a,$01]
	jbsr	unsuspend_tasks_b015                            	| [$5291: call $B015]
	move.b	nb_credits_minus_one_C024,d0    	| [$5294: ld   a,(nb_credits_minus_one_C024)]
												| [$5297: and  a]
* after game over check if there are still credits
	jeq	task_5250                             	| [$5298: jp   z,$5250]
	lea	map_index_C900,a2              	| [$529b: ld   ix,map_index_C900]
	lea	unknown_C908,a3                	| [$529f: ld   iy,unknown_C908]
	clr.b	d0                               	| [$52a3: ld   a,$00]
	move.b	d0,(0x00,a2)                    	| [$52a5: ld   (ix+$00),a]
	move.b	d0,(0x00,a3)                    	| [$52a8: ld   (iy+$00),a]
	lea	table_534d(pc),a0                  	| [$52ab: ld   hl,table_534d]
	move.b	(a0),d0                         	| [$52ae: ld   a,(hl)]
	move.b	d0,(0x01,a2)                    	| [$52af: ld   (ix+$01),a]
	move.b	d0,(0x01,a3)                    	| [$52b2: ld   (iy+$01),a]
	move.b	d6,(0x02,a2)                    	| [$52b5: ld   (ix+$02),l]
	move.b	d6,(0x02,a3)                    	| [$52b8: ld   (iy+$02),l]
	move.b	d5,(0x03,a2)                    	| [$52bb: ld   (ix+$03),h]
	move.b	d5,(0x03,a3)                    	| [$52be: ld   (iy+$03),h]
	clr.b	d0                               	| [$52c1: ld   a,$00]
	move.b	d0,(0x04,a2)                    	| [$52c3: ld   (ix+$04),a]
	move.b	d0,(0x04,a3)                    	| [$52c6: ld   (iy+$04),a]
	move.b	d0,(0x05,a2)                    	| [$52c9: ld   (ix+$05),a]
	move.b	d0,(0x05,a3)                    	| [$52cc: ld   (iy+$05),a]
	move.b	d0,(0x06,a2)                    	| [$52cf: ld   (ix+$06),a]
	move.b	d0,(0x06,a3)                    	| [$52d2: ld   (iy+$06),a]
	move.b	d0,(0x07,a2)                    	| [$52d5: ld   (ix+$07),a]
	move.b	d0,(0x07,a3)                    	| [$52d8: ld   (iy+$07),a]
	move.b	d0,level_number_C0DC            	| [$52db: ld   (level_number_C0DC),a]
	move.b	d0,unknown_C0DD                 	| [$52de: ld   (unknown_C0DD),a]
	move.b	d0,unknown_C0DE                 	| [$52e1: ld   (unknown_C0DE),a]
	move.b	d0,unknown_C0DF                 	| [$52e4: ld   (unknown_C0DF),a]
	move.b	d0,unknown_C0E0                 	| [$52e7: ld   (unknown_C0E0),a]
	move.b	d0,unknown_C0E1                 	| [$52ea: ld   (unknown_C0E1),a]
	move.b	d0,unknown_C0E2                 	| [$52ed: ld   (unknown_C0E2),a]
	move.b	d0,unknown_C0E3                 	| [$52f0: ld   (unknown_C0E3),a]
	move.b	d0,unknown_C0E4                 	| [$52f3: ld   (unknown_C0E4),a]
	move.b	d0,unknown_C0E5                 	| [$52f6: ld   (unknown_C0E5),a]
	lea	players_type_human_or_cpu_flags_C02D,a0	| [$52f9: ld   hl,players_type_human_or_cpu_flags_C02D]
	bset.b	#0,(a0)                         	| [$52fc: set  0,(hl)]
	bset.b	#2,(a0)                         	| [$52fe: set  2,(hl)]
	lea	nb_credits_minus_one_C024,a0   	| [$5300: ld   hl,nb_credits_minus_one_C024]
	move.b	(a0),d0                         	| [$5303: ld   a,(hl)]
	subq.b	#0x01,d0                        	| [$5304: sub  $01]
*daa
	move.b	d0,(a0)                         	| [$5307: ld   (hl),a]
	jbsr	clear_C7xx_B01E                    	| [$5308: call $B01E]
	move.b	#0x01,d0                        	| [$530b: ld   a,$01]
	jbsr	suspend_task_B05A            	| [$530d: call suspend_task_B05A]
	move.w	#0x003C,d1                      	| [$5310: ld   bc,$003C] 60
	jbsr	fill_video_and_attribute_memory_B030                    	| [$5313: call $B030]
	move.b	#0x80,d0                        	| [$5316: ld   a,$80]
	jbsr	play_sound_B072                   	| [$5318: call play_sound_B072]
l_531b:
	jbsr	disable_interrupts_B0BD                            	| [$531b: call $B0C0]
	jbsr	display_start_message_7b92                           	| [$531e: call $7B92]
	jbsr	display_credits_7C1C                            	| [$5321: call $7C1C]
	jbsr	check_coin_ports_B069                            	| [$5324: call $B069]
	btst.b	#2,d0                           	| [$5327: bit  2,a]
	jne	l_5266                             	| [$5329: jp   nz,$5266]
	move.b	nb_credits_minus_one_C024,d0    	| [$532c: ld   a,(nb_credits_minus_one_C024)]
	tst.b	d0                               	| [$532f: and  a]
	jeq	l_531b                             	| [$5330: jp   z,$531B]
	jbsr	check_coin_ports_B069                            	| [$5333: call $B069]
	btst.b	#3,d0                           	| [$5336: bit  3,a]
	jeq	l_531b                             	| [$5338: jp   z,$531B]
* set 2 player mode
	lea	players_type_human_or_cpu_flags_C02D(pc),a0	| [$533b: ld   hl,players_type_human_or_cpu_flags_C02D]
	bset.b	#1,(a0)                         	| [$533e: set  1,(hl)]
	bset.b	#3,(a0)                         	| [$5340: set  3,(hl)]
	lea	nb_credits_minus_one_C024(pc),a0   	| [$5342: ld   hl,nb_credits_minus_one_C024]
	move.b	(a0),d0                         	| [$5345: ld   a,(hl)]
	subq.b	#0x01,d0                        	| [$5346: sub  $01]
*daa
	move.b	d0,(a0)                         	| [$5349: ld   (hl),a]
	jra	l_5266                             	| [$534a: jp   $5266]
table_534d:
	dc.b	0x53,0x27,0x07,0x37,0x17,0x55,0x24,0x04 | table_534d
	dc.b	0x34,0x14,0x55,0x22,0x02,0x32,0x12,0x55 | $5355
	dc.b	0x20,0x00,0x30,0x10,0x55,0x2a,0x0a,0x3a | $535d
	dc.b	0x1a,0x55,0x28,0x08,0x38,0x18,0x55,0x25 | $5365
	dc.b	0x05,0x35,0x15,0x55,0x29,0x09,0x39,0x19 | $536d
	dc.b	0x55,0x26,0x06,0x36,0x16,0x55,0x23,0x03 | $5375
	dc.b	0x33,0x13,0x55,0x21,0x01,0x31,0x11,0x55 | $537d
	dc.b	0x2b,0x0b,0x3b,0x1b,0x55,0x27,0x07,0x37 | $5385
	dc.b	0x17,0x55,0x24,0x04,0x34,0x14,0x55,0x22 | $538d
	dc.b	0x02,0x32,0x12,0x55,0x20,0x00,0x30,0x10 | $5395
	dc.b	0x55,0x2a,0x0a,0x3a,0x1a,0x55,0x28,0x08 | $539d
	dc.b	0x38,0x18,0x55,0x25,0x05,0x35,0x15,0x55 | $53a5
	dc.b	0x29,0x09,0x39,0x19,0x55,0x26,0x06,0x36 | $53ad
	dc.b	0x16,0x55,0x23,0x03,0x33,0x13,0x55,0x21 | $53b5
	dc.b	0x01,0x31,0x11,0x55,0x2b,0x0b,0xff,0x4d | $53bd
	dc.b	0x53 | $53c5
table_53C6:
	dc.b	0x54,0x40,0x51
table_53C9:
	dc.b	0x3b,0x54,0x51 | table_53C9
table_53CC:
	dc.b	0xd2,0xd0,0x80,0xff,0xcc,0x53 | table_53CC
	.align	2

display_start_message_7b92:
	move.b	nb_credits_minus_one_C024,d0    	| [$7b92: ld   a,(nb_credits_minus_one_C024)]
	lea	start_1P_message_7BA6(pc),a0       	| [$7b95: ld   hl,start_1P_message_7BA6]
	cmp.b	#0x00,d0                         	| [$7b98: cp   $00]
	jeq	l_7ba0                             	| [$7b9a: jp   z,$7BA0]
	lea	start_2P_message_7BCA(pc),a0       	| [$7b9d: ld   hl,start_2P_message_7BCA]
l_7ba0:
	move.b	#0x98,d3                        	| [$7ba0: ld   d,$98]
	jbsr	display_text_B039                 	| [$7ba2: call display_text_B039]
	rts                                    	| [$7ba5: ret]
start_1P_message_7BA6:
	dc.b	0x05,0x0a,0x19,0x1b,0x0e,0x1c,0x1c,0x3c | table_7BA6
	dc.b	0x01,0x19,0x3c,0x0b,0x1e,0x1d,0x1d,0x18 | $7bae
	dc.b	0x17,0x3c,0x0f,0x18,0x1b,0xfe,0x09,0x0c | $7bb6
	dc.b	0x1c,0x12,0x17,0x10,0x15,0x0e,0x3c,0x19 | $7bbe
	dc.b	0x15,0x0a,0x22,0xff | $7bc6
start_2P_message_7BCA:
	dc.b	0x05,0x0a,0x19,0x1b,0x0e,0x1c,0x1c,0x3c | table_7BCA
	dc.b	0x01,0x19,0x3c,0x0b,0x1e,0x1d,0x1d,0x18 | $7bd2
	dc.b	0x17,0x3c,0x0f,0x18,0x1b,0xfe,0x09,0x0c | $7bda
	dc.b	0x1c,0x12,0x17,0x10,0x15,0x0e,0x3c,0x19 | $7be2
	dc.b	0x15,0x0a,0x22,0xfe,0x05,0x0e,0x19,0x1b | $7bea
	dc.b	0x0e,0x1c,0x1c,0x3c,0x02,0x19,0x3c,0x0b | $7bf2
	dc.b	0x1e,0x1d,0x1d,0x18,0x17,0x3c,0x0f,0x18 | $7bfa
	dc.b	0x1b,0xfe,0x04,0x10,0x0f,0x12,0x10,0x11 | $7c02
	dc.b	0x1d,0x3c,0x0b,0x0e,0x1d,0x20,0x0e,0x0e | $7c0a
	dc.b	0x17,0x3c,0x19,0x15,0x0a,0x22,0x0e,0x1b | $7c12
	dc.b	0x1c,0xff | $7c1a

display_credits_7C1C:
	lea	credit_text_7C54(pc),a0            	| [$7c1c: ld   hl,credit_text_7C54]
	move.b	#0x98,d3                        	| [$7c1f: ld   d,$98]
	jbsr	display_text_B039                 	| [$7c21: call display_text_B039]
											| [$7c24: ld   hl,$1F1C]
	move.w	#0x1C1F,temp_numeric_buffer_CF00     	| [$7c27: ld   (temp_numeric_buffer_CF00),hl]
* at least during "press 1P button" screen
* check number of credits, maybe to display them
* as there's a "daa" instruction (bcd conversion)
	move.b	nb_credits_minus_one_C024,d0    	| [$7c2a: ld   a,(nb_credits_minus_one_C024)]
	addq.b	#0x01,d0                        	| [$7c2d: add  a,$01]
**daa
	move.b	d0,d1                           	| [$7c30: ld   b,a]
	lea	temp_numeric_buffer_CF00(pc),a2    	| [$7c31: ld   ix,temp_numeric_buffer_CF00]
	and.b	#0x0F,d0                         	| [$7c35: and  $0F]
	move.b	d0,(0x03,a2)                    	| [$7c37: ld   (ix+$03),a]
	move.b	d1,d0                           	| [$7c3a: ld   a,b]
	lsr.b	#4,d0                            	| [$7c3b: srl  a] * 4
	move.b	d0,(0x02,a2)                    	| [$7c43: ld   (ix+$02),a]
	st.b	d0                                	| [$7c46: ld   a,$FF]
	move.b	d0,(0x04,a2)                    	| [$7c48: ld   (ix+$04),a]
	lea	temp_numeric_buffer_CF00(pc),a0    	| [$7c4b: ld   hl,temp_numeric_buffer_CF00]
	move.b	#0x98,d3                        	| [$7c4e: ld   d,$98]
	jbsr	display_text_B039                 	| [$7c50: call display_text_B039]
	rts                                    	| [$7c53: ret]
credit_text_7C54:
	dc.b	0x15,0x1f,0x0c,0x1b,0x0e,0x0d,0x12,0x1d | credit_7C54
	dc.b	0xff | $7c5c
	.align	2
	
unsuspend_tasks_b015:
	jra	unsuspend_tasks_b171                             	| [$b015: jp   unsuspend_tasks_b171]

clear_C7xx_B01E:
	jra	clear_C7xx_B2B2                    	| [$b01e: jp   clear_C7xx_B2B2]
clear_zone_B021:
	jra	clear_zone_B2BD                    	| [$b021: jp   clear_zone_B2BD]

fill_video_and_attribute_memory_B030:
	jra	fill_video_and_attribute_memory_B316	| [$b030: jp   fill_video_and_attribute_memory_B316]

display_text_B039:
	jra	display_text_B357                  	| [$b039: jp   display_text_B357]

startup_B045:
	jra	startup_B469                       	| [$b045: jp   startup_B469]

suspend_task_B05A:
	jra	suspend_task_B65E             	| [$b05a: jp   suspend_task_B65E]

unsuspend_task_B054:
	jra	unsuspend_task_B5CD                	| [$b054: jp   unsuspend_task_B5CD]

schedule_task_to_start_B057:
	jra	schedule_task_to_start_B620                  	| [$b057: jp   schedule_task_to_start_B620]

set_normal_screen_b060:
	jra	set_normal_screen_bb72                             	| [$b060: jp   $BB72]
check_coin_ports_B069:
	jra	check_coin_ports_BB82              	| [$b069: jp   check_coin_ports_BB82]

play_sound_B072:
	jbsr	osd_sound_start
	rts
	
display_error_text_B075:
	jra	display_error_text_B186            	| [$b075: jp   display_error_text_B186]

stop_sound_b0ae:
	jra	stop_sound_BBDF                    	| [$b0ae: jp   stop_sound_BBDF]

disable_interrupts_B0BD:
	jra		disable_interrupts_BBE2
	
unsuspend_tasks_b171:
	cmp.b	#0x18,d0                         	| [unsuspend_tasks_b171: cp   $18]
	bcs.b	0f
	jbsr	display_error_text_B186           	| [$b173: call nc,display_error_text_B186]
0:

	move.l	a3,-(sp)                        	| [$b176: push iy]
l_b178:
	move.w	d0,-(sp)                        	| [$b178: push af]
	jbsr	unsuspend_task_B5CD               	| [$b179: call unsuspend_task_B5CD]
	move.w	(sp)+,d0                        	| [$b17c: pop  af]
	addq.b	#1,d0                           	| [$b17d: inc  a]
	cmp.b	#0x18,d0                         	| [$b17e: cp   $18]
	jne	l_b178                             	| [$b180: jp   nz,$B178]
	move.l	(sp)+,a3                        	| [$b183: pop  iy]
	rts                                    	| [$b185: ret]

display_error_text_B186:
	move.l	(sp)+,a2                        	| [$b186: pop  ix]
	jbsr	disable_interrupts_BBE2           	| [$b188: call disable_interrupts_BBE2]
	move.w	d0,-(sp)                        	| [$b18b: push af]
	movem.w	d1/d2,-(sp)                    	| [$b18c: push bc]
	move.l	a4,-(sp)                        	| [$b18c: push bc]
	movem.w	d3/d4,-(sp)                    	| [$b18d: push de]
	move.l	a1,-(sp)                        	| [$b18d: push de]

	move.l	a0,-(sp)                        	| [$b18e: push hl]

	move.l	a3,-(sp)                        	| [$b18f: push iy]
	lea	error_text_B1A3(pc),a0             	| [$b191: ld   hl,error_text_B1A3] ERROR
	move.b	#0x98,d3                        	| [$b194: ld   d,$98]
	jbsr	display_text_B357                 	| [$b196: call display_text_B357]
	move.l	(sp)+,a3                        	| [$b199: pop  iy]
	move.l	(sp)+,a0                        	| [$b19b: pop  hl]
	move.l	(sp)+,a1                        	| [$b19c: pop  de]
	movem.w	(sp)+,d3/d4                    	| [$b19c: pop  de]
	move.l	(sp)+,a4                        	| [$b19d: pop  bc]
	movem.w	(sp)+,d1/d2                    	| [$b19d: pop  bc]
	move.w	(sp)+,d0                        	| [$b19e: pop  af]
* infinite loop, all registers are preserved, inc. call address
* probably used by the devs as an "assert failed" routine, where they could
* track down abnormal values before it really crashes
l_b19f:
	bsr		osd_break                                    	| [$b19f: nop]
	jra	l_b19f                             	| [$b1a0: jp   $B19F]

error_text_B1A3:
	dc.b	0x0e,0x10,0x0e,0x1b,0x1b,0x18,0x1b,0xff  | "ERROR"
	.align	2
	
clear_C7xx_B2B2:
	clr.b	d0                               	| [$b2b2: xor  a]
	lea	referee_x_pos_C700,a0          	| [$b2b3: ld   hl,referee_x_pos_C700]
	lea	unknown_C7FB,a4                	| [$b2b6: ld   bc,unknown_C7FB]
	jbsr	fill_zone_with_a_B2CA             	| [$b2b9: call fill_zone_with_a_B2CA]
	rts                                    	| [$b2bc: ret]

* < HL: pointer on zone to clear
* < BC: size
clear_zone_B2BD:
	move.l	(sp)+,a2                        	| [$b2bd: pop  ix] return address in ix
l_b2bf:
	clr.b	(a0)+                             	| [$b2bf: ld   (hl),$00] set to 0
									| [$b2c1: inc  hl] increment hl
	subq.w	#1,d1                           	| [$b2c2: dec  bc] decrement bc counter
											| [$b2c3: ld   a,b] test b=c=0
												| [$b2c4: or   c]
	jne	l_b2bf                             	| [$b2c5: jp   nz,$B2BF] not 0, keep looping
	jra	(a2)      
	

* < a: character to store
* < a0: start address
* < a4: end address (included)
fill_zone_with_a_B2CA:
	addq.w	#1,a4                           	| [$b2ca: inc  bc]
	move.b	d0,d3                           	| [$b2cb: ld   d,a]
l_b2cc:
	move.b	d3,(a0)+                         	| [$b2cc: ld   (hl),d]
	cmp.l	a0,a4										| [$b2cd: inc  hl]
	jne	l_b2cc                             	| [$b2d0: jp   nz,$B2CC]
	rts                                    	| [$b2d8: ret]
	
* < D5/D6: X,Y
* > D6: screen address
compute_screen_address_from_XY_B2F6:
	clr.b	d3                               	| [$b2f6: ld   d,$00]
	move.b	d5,d4                           	| [$b2f8: ld   e,h]
	asl.b	#1,d4                            	| [$b2f9: sla  e]
	roxl.b	#1,d3                           	| [$b2fb: rl   d]
	asl.b	#1,d4                            	| [$b2fd: sla  e]
	roxl.b	#1,d3                           	| [$b2ff: rl   d]
	asl.b	#1,d4                            	| [$b301: sla  e]
	roxl.b	#1,d3                           	| [$b303: rl   d]
	asl.b	#1,d4                            	| [$b305: sla  e]
	roxl.b	#1,d3                           	| [$b307: rl   d]
	asl.b	#1,d4                            	| [$b309: sla  e]
	roxl.b	#1,d3                           	| [$b30b: rl   d] results in DE = H*32
	clr.b	d0                               	| [$b30d: xor  a]
	move.b	d0,d5                           	| [$b30e: ld   h,a]
	lsl.w	#8,d5
	move.b	d6,d5
	
	lsl.w	#8,d3
	move.b	d4,d3
	move.w	#0xD3E0,d6                      	| [$b30f: ld   bc,$D3E0] screen address
	add.w	d5,d6                            	| [$b312: add  hl,bc]

	sub.w	d3,d6							| [sbc  hl,de]
	rts                                    	| [$b315: ret]


* fill video & attribute memory with an uniform value
* < d2: what to set in video memory
* < d1: what to set in attribute memory
*
fill_video_and_attribute_memory_B316:
	move.w	#0xD000,d4                      	| [$b316: ld   hl,$D000]
	move.w	#0xD400,d5                      	| [$b316: ld   hl,$D000]
	move.w	#0x400,d3                      	| [$b31d: ld   de,$0400]
l_b320:
	move.w	d4,d6
	move.b	d2,d0                        	| [$b320: ld   (hl),c]
	jbsr	osd_w_videoram
	move.w	d5,d6
	move.b	d1,d0                    	| [$b324: ld   (ix+$00),b]
	jbsr	osd_w_colorram
	addq.w	#1,d4                           	| [$b327: inc  hl]
	addq.w	#1,d5                           	| [$b328: inc  ix]
	subq.w	#1,d3                           	| [$b32a: dec  de]
	jne	l_b320                             	| [$b32d: jp   nz,$B320]
	rts                                    	| [$b330: ret]

* display text
* <  hl pointer on text
* : format x y text (not in ASCII, tile-index based), ends by $FF
* codes are:
* 0-9: digits
* 10-35: A-Z
* 0x3C: space
* 0xFE: line feed, goto next line
* 0xFF: end

* <  d  color attribute

display_text_B357:

	move.l	a3,-(sp)                        	| [$b357: push iy]
	move.l	a0,a3                        	| [$b359: push hl]
	                        	| [$b35a: pop  iy]
	* a3 points on coords , color, + text
l_b35c:
	* get X
	move.b	(a3)+,d0                    	| [$b35c: ld   a,(iy+$00)]
	move.b	d0,d5                           	| [$b35f: ld   h,a]
											| [$b360: inc  iy]
	* get Y
	move.b	(a3),d0                    	| [$b362: ld   a,(iy+$00)]
	move.b	d0,d6                           	| [$b365: ld   l,a]
	movem.w	d3/d4,-(sp)                    	| [$b366: push de]
	move.l	a1,-(sp)                        	| [$b366: push de]
	jbsr	compute_screen_address_from_XY_B2F6	| [$b367: call compute_screen_address_from_XY_B2F6]
	move.l	(sp)+,a1                        	| [$b36a: pop  de]
	movem.w	(sp)+,d3/d4                    	| [$b36a: pop  de]
l_b36b:
	addq.w	#1,a3                           	| [$b36b: inc  iy]
	move.b	(a3),d0                    	| [$b36d: ld   a,(iy+$00)]
	cmp.b	#0xFF,d0                         	| [$b370: cp   $FF] end of string?
	jeq	l_b38e                             	| [$b372: jp   z,$B38E]
* FE: end of string
	cmp.b	#0xFE,d0                         	| [$b375: cp   $FE]
	jne	l_b37f                             	| [$b377: jp   nz,$B37F]
	addq.w	#1,a3                           	| [$b37a: inc  iy]
	jra	l_b35c                             	| [$b37c: jp   $B35C]
l_b37f:
	jbsr	osd_w_videoram                 	| [$b37f: ld   (hl),a]
											| [$b380: ld   bc,$0400]
	add.w	#0x400,d6                            	| [$b383: add  hl,bc] attribute memory
	move.b	d3,d0
	jbsr	osd_w_colorram                         	| [$b384: ld   (hl),d]
	                      	| [$b385: ld   bc,$0420] next char
	                               	| [$b388: xor  a]
	sub.w	#0x420,d6				| [sbc  hl,bc]
	jra	l_b36b                             	| [$b38b: jp   $B36B]
l_b38e:
	move.l	(sp)+,a3                        	| [$b38e: pop  iy]
	rts                                    	| [$b390: ret]



startup_B469:

	move.b	#0x42,d0                        	| [$b469: ld   a,$42]
	move.b	d0,unknown_CD21                 	| [$b46b: ld   (unknown_CD21),a]
	lea		stack_top_CF00,sp			| ld   sp,stack_top_CF00			| set stack
	jbsr	disable_interrupts_BBE2           	| [$b471: call disable_interrupts_BBE2]
* clear part of RAM
	lea	active_task_bit_table_C000,a0                	| [$b479: ld   hl,active_task_bit_table_C000]
	move.w	#0x0080,d1                      	| [$b47c: ld   bc,$0080] immediate value 128
	jbsr	clear_zone_B2BD                   	| [$b47f: call clear_zone_B2BD]
	jbsr	init_ram_BB41                     	| [$b482: call init_ram_BB41]
	st.b	d0                                	| [$b485: ld   a,$FF]
	move.b	d0,unknown_C02C                 	| [$b487: ld   (unknown_C02C),a]
	jbsr	enable_interrupts_BBE2            	| [$b48a: call enable_interrupts_BBE2]

* this is called by most routines that want to yield control to this mainloop
jump_to_mainloop_B48D:
	lea		stack_top_CF00,sp			| ld   sp,stack_top_CF00			| set stack
	jbsr	enable_interrupts_BBE2            	| [$b490: call enable_interrupts_BBE2]

* main "task" scheduler
* loop until one of the 2 timers/counters is nonzero
* jump at different locations
scheduler_loop_b493:
	lea	unknown_C006,a0                	| [$b493: ld   hl,unknown_C006]
	tst.b	nb_tasks_to_start_C029                 	| [$b496: ld   a,(nb_tasks_to_start_C029)]
											| [$b499: and  a]
	jne	run_a_task_b4a7                             	| [$b49a: jp   nz,$B4A7]

	tst.b	nb_suspended_tasks_C02A                 	| [$b49d: ld   a,(nb_suspended_tasks_C02A)]
											| [$b4a0: and  a]
	jne	resume_a_task_b503                             	| [$b4a1: jp   nz,$B503]
	jra	scheduler_loop_b493                             	| [$b4a4: jp   $B493]

*
* < A0 (HL): task bits structure (always 0xC006)
run_a_task_b4a7:
	clr.b	d0                               	| [$b4a7: xor  a]
	move.b	d0,d3                           	| [$b4a8: ld   d,a]
* check change of bitfield state $C006-$C00B notify bitfield changes
* looks like an event table: each routine can post events by setting
* bits, and the events are acknowledged by bitclears.
* depending on the bits set, we jump to different routines
*
* this is a task scheduler, with stack location change and all!!!
* find a non-zero slot
	move.b	#0x6,d6		| coupling D6 (L) with A0 (HL) to point on 0xC00C
	cmp.b	(a0),d0                          	| [$b4a9: cp   (hl)]
	jne	l_b4b8                             	| [$b4aa: jp   nz,$B4B8]
	addq.w	#1,a0
	addq.b	#1,d6                           	| [$b4ad: inc  l]
	cmp.b	(a0),d0                          	| [$b4ae: cp   (hl)]
	jne	l_b4b8                             	| [$b4af: jp   nz,$B4B8]
	addq.w	#1,a0
	addq.b	#1,d6                           	| [$b4b2: inc  l]
	cmp.b	(a0),d0                          	| [$b4b3: cp   (hl)]
	jne	l_b4b8                             	| [$b4b4: jp   nz,$B4B8]
	* if not found pick the last slot (probably replace last running task if any)
	addq.w	#1,a0
	addq.b	#1,d6                           	| [$b4b7: inc  l]
l_b4b8:
	move.b	d6,d0                           	| [$b4b8: ld   a,l]
	subq.b	#0x06,d0                        	| [$b4b9: sub  $06] if first 0, then sub 06 gives 0
	moveq	#0,d4
	move.b	d0,d4                           	| [$b4bb: ld   e,a]
	rol.b	#3,d4                            	| [$b4bc: rlc  e] times 8
	clr.w	d2                               	| [$b4c2: ld   b,$00]
	move.b	(a0),d2                         	| [$b4c4: ld   c,(hl)]
												| [$b4c5: and  a] clear carry
	add.w	d2,d2                           	| [$b4c6: rl   c] times 2 on 16 bits (bc)
												| [$b4c8: rl   b]
	lea	table_B87D(pc),a2                  	| [$b4ca: ld   ix,table_B87D]
	add.w	d2,a2                            	| [$b4ce: add  ix,bc]

	move.b	(0x00,a2),d1                    	| [$b4d0: ld   b,(ix+$00)]
	move.b	(0x01,a2),d0                    	| [$b4d3: ld   a,(ix+$01)]
	add.b	d4,d0                            	| [$b4d6: add  a,e]
	move.b	d0,d4                           	| [$b4d7: ld   e,a]
	move.b	d0,player_2_attack_flags_C028   	| [$b4d8: ld   (player_2_attack_flags_C028),a]
	move.b	d1,d0                           	| [$b4db: ld   a,b]
	move.b	(a0),d7
	eor.b	d7,d0                            	| [$b4dc: xor  (hl)]
	* kind of zeroes slot, not of what's done here
	move.b	d0,(a0)                         	| [$b4dd: ld   (hl),a]

	add.w	d4,d4                            	| [$b4de: rlc  e]
	add.w	d4,d4                            	| double (long address)
	                               	| [$b4e0: ld   d,$00]
	lea	task_stack_buffer_table_B825(pc),a3      	| [$b4e2: ld   iy,task_stack_buffer_table_B825]
	add.w	d4,a3                            	| [$b4e6: add  iy,de]
	* switch stack pointer according to routine we jump to!!
	* (seems that they've coded a mini-OS for this game!)
	
	move.l	(a3),a7                    	| [$b4e8: ld   l,(iy+$00)]
										| [$b4eb: ld   h,(iy+$01)]
	
									| [$b4ef: ld   hl,nb_tasks_to_start_C029]
	subq.b	#1,nb_tasks_to_start_C029                         	| [$b4f2: dec  (hl)]
	lea		task_address_table_0020,a3                      	| [$b4f3: ld   iy,$0020] 32
	add.w	d4,a3                            	| [$b4f7: add  iy,de]

	move.l	(a3),a0                    	| [$b4f9: ld   l,(iy+$00)]
										| [$b4fc: ld   h,(iy+$01)]
	jbsr	enable_interrupts_BBE2            	| [$b4ff: call enable_interrupts_BBE2]
* called several times at startup
* $5250
* $53D2
* $544F
* $6491
* $7C5D
* $6D5E
* $B099
* $B09C
* $B09F
*
* then called when screen changes

	* starts the task
	jmp	(a0)                               	| [$b502: jp   (hl)]


resume_a_task_b503:
	jbsr	disable_interrupts_BBE2           	| [$b503: call disable_interrupts_BBE2]
	lea	unknown_C00C(pc),a0                	| [$b506: ld   hl,unknown_C00C]
										| [$b509: ld   iy,unknown_C00C]
	tst.l	(a0)                    	| [$b50d: ld   a,(iy+$00)] check for free slots
										| [$b510: or   (iy+$01)]
										| [$b513: or   (iy+$02)]
										| [$b516: or   (iy+$03)]
	jeq	jump_to_mainloop_B48D              	| [$b519: jp   z,jump_to_mainloop_B48D]
	clr.w	d4
	clr.b	d0                               	| [$b51c: xor  a]
	move.b	d0,d4 
	move.b	#0xC,d6			| lsw of original 0xC00C HL
	* compute free task slot?				| [$b51d: ld   d,a]
	cmp.b	(a0),d0                          	| [$b51e: cp   (hl)]
	jne	l_b52d                             	| [$b51f: jp   nz,$B52D]
	addq.w	#1,a0
	addq.w	#1,d6                           	| [$b522: inc  l]
	* check for 1 in task id
	cmp.b	(a0),d0                          	| [$b523: cp   (hl)]
	jne	l_b52d                             	| [$b524: jp   nz,$B52D]
	* check for 2 in task id
	addq.w	#1,a0
	addq.b	#1,d6                           	| [$b527: inc  l]
	cmp.b	(a0),d0                          	| [$b528: cp   (hl)]
	jne	l_b52d                             	| [$b529: jp   nz,$B52D]
	* has to be that slot
	addq.b	#1,d6                           	| [$b52c: inc  l]
l_b52d:
	move.b	d6,d0                           	| [$b52d: ld   a,l]
	sub.b	#0x0C,d0                         	| [$b52e: sub  $0C]
	move.b	d0,d4                           	| [$b530: ld   e,a]
	rol.b	#3,d4                            	| [$b531: rlc  e] * 3 multiply by 8
	tst.b	d0                               	| [$b537: and  a] clear carry?
	clr.w	d1                               	| [$b538: ld   b,$00]
	* get non-zero slot id
	move.b	(a0),d1                         	| [$b53a: ld   c,(hl)]
	add.w	d1,d1                           	| [$b53b: rl   c]
												| [$b53d: rl   b]
	lea	table_B87D(pc),a2                  	| [$b53f: ld   ix,table_B87D]
	add.w	d1,a2                            	| [$b543: add  ix,bc]*
	* get properties
	move.b	(0x00,a2),d1                    	| [$b545: ld   b,(ix+$00)]
	move.b	(0x01,a2),d0                    	| [$b548: ld   a,(ix+$01)]
	add.b	d4,d0                            	| [$b54b: add  a,e]
	move.b	d0,d4                           	| [$b54c: ld   e,a]
	move.b	d0,player_2_attack_flags_C028   	| [$b54d: ld   (player_2_attack_flags_C028),a]
	move.b	d1,d0                           	| [$b550: ld   a,b]
	move.b	(a0),d7
	eor.b	d7,d0                    	      	| [$b551: xor  (hl)]
	* zero/mask out slot
	move.b	d0,(a0)                         	| [$b552: ld   (hl),a]
	add.w	d4,d4                            	| [$b553: rlc  e]
	add.w	d4,d4                            	| double offset (long needs *4)
												| [$b555: ld   d,$00]
	lea	task_struct_table_B7E5(pc),a0                  	| [$b557: ld   hl,table_B7E5]
	add.w	d4,a0                            	| [$b55a: add  hl,de]
	* a0 = task structure
	* rather offset vs bottom than full address, as it would shift
	* task structure offsets. It's complex enough to avoid it!
	lea		stack_bottom_C400,a1
	add.w	(a0),a1
	
	* sets stack for this task 
	* looks like a mini-os with a task
	* scheduler and all!!!
	move.l	a1,sp

	* switch registers, not needed, a0 is still task structure
	* exg	a1,a0                              	| [$b564: ex   de,hl]
										| [$b565: ld   de,$0004] 4
	addq.w	#4,a0                            	| [$b568: add  hl,de]
	* get another task property
	move.b	(a0)+,d1                         	| [$b569: ld   b,(hl)]
									| [$b56a: inc  hl]
	* get another task property (context)
	move.b	(a0),d0                         	| [$b56b: ld   a,(hl)]
	lea	nb_suspended_tasks_C02A(pc),a0                	| [$b56c: ld   hl,nb_suspended_tasks_C02A]
	subq.b	#1,(a0)                         	| [$b56f: dec  (hl)]
	jbsr	enable_interrupts_BBE2            	| [$b570: call enable_interrupts_BBE2]
	* returns with stack properly set: returns to stack & resumes it
	rts                                    	| [$b573: ret]


unsuspend_task_B5CD:
	bsr		osd_break
	nop
	nop
	nop
	nop
	jbsr	disable_interrupts_BBE2           	| [$b5cd: call disable_interrupts_BBE2]
	lea	active_task_bit_table_C000(pc),a0                	| [$b5d0: ld   hl,active_task_bit_table_C000]
	move.b	d0,d2                           	| [$b5d3: ld   c,a]
	moveq	#0,d1                               	| [$b5d4: ld   b,$00]
	moveq	#0,d3                      	| [$b5d6: ld   de,$0000] 0
	and.b	#0x07,d0                         	| [$b5d9: and  $07]
	move.b	d0,d3                           	| [$b5db: ld   e,a]
	move.b	d2,d0                           	| [$b5dc: ld   a,c]
	and.b	#0xF8,d0                         	| [$b5dd: and  $F8]
	roxr.b	#3,d0                           	| [$b5df: rra] * 3
	move.b	d0,d1                           	| [$b5e2: ld   c,a]
	add.w	d1,a0                            	| [$b5e3: add  hl,bc]

	lea	powers_of_2_table_B875(pc),a2      	| [$b5e4: ld   ix,powers_of_2_table_B875]
	add.w	d3,a2                            	| [$b5e8: add  ix,de]

	move.b	(a2),d0                    	| [$b5ea: ld   a,(ix+$00)]
	move.b	d0,d1                           	| [$b5ed: ld   b,a]
	and.b	(a0),d0
	bne.b	0f
	rts                                    	| [$b5ef: ret  z]
0:
	move.b	d1,d0                           	| [$b5f0: ld   a,b]
	move.b	(a0),d7
	eor.b	d7,d0                            	| [$b5f1: xor  (hl)]
	move.b	d0,(a0)                         	| [$b5f2: ld   (hl),a]
	move.w	#0x0006,d3                      	| [$b5f3: ld   de,$0006] 6
	add.w	d3,a0                            	| [$b5f6: add  hl,de]
	move.b	d1,d0                           	| [$b5f7: ld   a,b]
	and.b	(a0),d0
	jeq	l_b607                             	| [$b5f9: jp   z,$B607]
	move.b	d1,d0                           	| [$b5fc: ld   a,b]
	move.b	(a0),d7
	eor.b	d7,d0                          	| [$b5fd: xor  (hl)]
	move.b	d0,(a0)                         	| [$b5fe: ld   (hl),a]
	lea	nb_tasks_to_start_C029(pc),a0      	| [$b5ff: ld   hl,nb_tasks_to_start_C029]
	subq.b	#1,(a0)                         	| [$b602: dec  (hl)]
	jbsr	enable_interrupts_BBE2            	| [$b603: call enable_interrupts_BBE2]
	rts                                    	| [$b606: ret]

l_b607:
	add.w	d3,a0                            	| [$b607: add  hl,de]
	move.b	d1,d0                           	| [$b608: ld   a,b]
	and.b	(a0),d0
	jeq	l_b618                             	| [$b60a: jp   z,$B618]
	move.b	d1,d0                           	| [$b60d: ld   a,b]
	move.b	(a0),d7
	eor.b	d7,d0                            	| [$b5fd: xor  (hl)]
	move.b	d0,(a0)                         	| [$b60f: ld   (hl),a]
	lea	nb_suspended_tasks_C02A(pc),a0     	| [$b610: ld   hl,nb_suspended_tasks_C02A]
	subq.b	#1,(a0)                         	| [$b613: dec  (hl)]
	jbsr	enable_interrupts_BBE2            	| [$b614: call enable_interrupts_BBE2]
	rts                                    	| [$b617: ret]

l_b618:
	add.w	d3,a0                            	| [$b618: add  hl,de]
	move.b	d1,d0                           	| [$b619: ld   a,b]
	move.b	(a0),d7
	eor.b	d7,d0                            	| [$b60e: xor  (hl)]
	move.b	d0,(a0)                         	| [$b61b: ld   (hl),a]
	jbsr	enable_interrupts_BBE2            	| [$b61c: call enable_interrupts_BBE2]
	rts                                    	| [$b61f: ret]

* < A: task index to schedule for start
* changes $C000-$C005 (bitfield 6*8 = 48 bits)
* returns changed bits in $C006-$C00B
* returns 0 if something changed, $FF otherwise
schedule_task_to_start_B620:
	jbsr	disable_interrupts_BBE2           	| [$b620: call disable_interrupts_BBE2]
	lea	active_task_bit_table_C000,a0                	| [$b623: ld   hl,active_task_bit_table_C000]
	move.b	d0,d2                           	| [$b626: ld   c,a]
	clr.w	d1                               	| [$b627: ld   b,$00]
	moveq	#0,d3                      	| [$b629: ld   de,$0000] 0
	and.b	#0x07,d0                         	| [$b62c: and  $07]
	move.b	d0,d3                           	| [$b62e: ld   e,a] A & 7 in E
	move.b	d2,d0                           	| [$b62f: ld   a,c] restore original A
	and.b	#0xF8,d0                         	| [$b630: and  $F8] mask it to get upper part (align on 8)
	roxr.b	#3,d0                           	| [$b632: rra] * 3 divide by 8
	move.b	d0,d1                           	| [$b635: ld   c,a]
	add.w	d1,a0                            	| [$b636: add  hl,bc]
	lea	powers_of_2_table_B875(pc),a2      	| [$b637: ld   ix,powers_of_2_table_B875]
	add.w	d3,a2                            	| [$b63b: add  ix,de]

* get proper power of 2 value in A (single bit value)
	move.b	(a2),d0                    	| [$b63d: ld   a,(ix+$00)]
	move.b	d0,d4                           	| [$b640: ld   e,a]
	and.b	(a0),d0							| [and  (hl)]
	jne	l_b658                             	| [$b642: jp   nz,$B658]
	move.b	d4,d0                           	| [$b645: ld   a,e]
	or.b	(a0),d0                           	| [$b646: or   (hl)]
	move.b	d0,(a0)                         	| [$b647: ld   (hl),a]
	moveq	#0x0006,d1                      	| [$b648: ld   bc,$0006] 6
        * next bitfield
	add.w	d1,a0                            	| [$b64b: add  hl,bc]
	move.b	d4,d0                           	| [$b64c: ld   a,e]
	or.b	(a0),d0                           	| [$b64d: or   (hl)]
	move.b	d0,(a0)                         	| [$b64e: ld   (hl),a]
	lea	nb_tasks_to_start_C029,a0      	| [$b64f: ld   hl,nb_tasks_to_start_C029]
	addq.b	#1,(a0)                         	| [$b652: inc  (hl)] increment timer
	clr.b	d0                               	| [$b653: xor  a]
	jbsr	enable_interrupts_BBE2            	| [$b654: call enable_interrupts_BBE2]
	rts                                    	| [$b657: ret]
l_b658:
	st.b	d0                                	| [$b658: ld   a,$FF]
	jbsr	enable_interrupts_BBE2            	| [$b65a: call enable_interrupts_BBE2]
	rts                                    	| [$b65d: ret]

* < a: time to suspend??
* this can be slower or faster if a computer is playing
* depending on the difficulty level
suspend_task_B65E:
	bsr		osd_break
	nop
	nop
	jbsr	disable_interrupts_BBE2           	| [$b65e: call disable_interrupts_BBE2]
	move.w	d0,-(sp)                        	| [$b661: push af]
	move.b	player_2_attack_flags_C028,d0   	| [$b662: ld   a,(player_2_attack_flags_C028)]
	lea	unknown_C012,a0                	| [$b665: ld   hl,unknown_C012]
	move.b	d0,d2                           	| [$b668: ld   c,a]
	clr.w	d1                               	| [$b669: ld   b,$00]
	move.w	#0x0000,d3                      	| [$b66b: ld   de,$0000] 0
	and.b	#0x07,d0                         	| [$b66e: and  $07]
	move.b	d0,d3                           	| [$b670: ld   e,a]
	move.b	d2,d0                           	| [$b671: ld   a,c]
	and.b	#0xF8,d0                         	| [$b672: and  $F8]
	roxr.b	#3,d0                           	| [$b674: rra] * 3
	move.b	d0,d1                           	| [$b677: ld   c,a]
	add.w	d1,a0                            	| [$b678: add  hl,bc]
	lea	powers_of_2_table_B875(pc),a2      	| [$b679: ld   ix,powers_of_2_table_B875]
	add.w	d3,a2                            	| [$b67d: add  ix,de]
	move.b	(a2),d0                    	| [$b67f: ld   a,(ix+$00)]
	or.b	(a0),d0                           	| [$b682: or   (hl)]
	move.b	d0,(a0)                         	| [$b683: ld   (hl),a]
	move.b	player_2_attack_flags_C028,d0   	| [$b684: ld   a,(player_2_attack_flags_C028)]
	lea	task_struct_C100,a3                	| [$b687: ld   iy,task_struct_C100]
	move.b	d0,d1                           	| [$b68b: ld   b,a]
	clr.b	d2                               	| [$b68c: ld   c,$00]
	tst.b	d0                               	| [$b68e: and  a]
	roxr.b	#1,d1                           	| [$b68f: rr   b]
	roxr.b	#1,d2                           	| [$b691: rr   c]
	roxr.b	#1,d1                           	| [$b693: rr   b]
	roxr.b	#1,d2                           	| [$b695: rr   c]
	roxr.b	#1,d1                           	| [$b697: rr   b]
	roxr.b	#1,d2                           	| [$b699: rr   c]
	lsl.w	#8,d1
	move.b	d2,d1
	add.w	d1,a3                            	| [$b69b: add  iy,bc]
	move.w	(sp)+,d0                        	| [$b69d: pop  af]
* writes in player struct + 2: number of frames to wait until next frame
	move.b	d0,(0x02,a3)                    	| [$b69e: ld   (iy+$02),a]
	* get current stack (rather stack offset so we fit in 16 bits) 
	* to store it in the task structure
	                      	                   | [$b6a1: ld   hl,$0000] 0
	move.l	sp,d0                            	| [$b6a4: add  hl,sp]
	sub.l	#stack_bottom_C400,d0
	move.w	d0,(a3)           | [$b6a5: ld   (iy+$00),l]
	                          | [$b6a8: ld   (iy+$01),h]

	
	jra	jump_to_mainloop_B48D              	| [$b6ab: jp   jump_to_mainloop_B48D]

* seems to suspend a task but also make up for that and unsuspend...
task_manipulation_B6AE:
	jbsr	disable_interrupts_BBE2           	| [$b6ae: call disable_interrupts_BBE2]
	movem.w	d1/d2,-(sp)                    	| [$b6b1: push bc]
	move.w	d0,-(sp)                        	| [$b6b2: push af]
	lea	active_task_bit_table_C000(pc),a0                	| [$b6b3: ld   hl,active_task_bit_table_C000]
	move.b	d0,d2                           	| [$b6b6: ld   c,a]
	clr.w	d1                               	| [$b6b7: ld   b,$00]
	moveq	#0,d3                      	| [$b6b9: ld   de,$0000] 0
	and.b	#0x07,d0                         	| [$b6bc: and  $07]
	move.b	d0,d3                           	| [$b6be: ld   e,a]
	move.b	d2,d0                           	| [$b6bf: ld   a,c]
	and.b	#0xF8,d0                         	| [$b6c0: and  $F8]
	roxr.b	#3,d0                           	| [$b6c2: rra] * 3
	move.b	d0,d1                           	| [$b6c5: ld   c,a]
	add.w	d1,a0                            	| [$b6c6: add  hl,bc]

	move.l	a0,-(sp)                        	| [$b6c7: push hl]
	lea	powers_of_2_table_B875(pc),a2      	| [$b6c8: ld   ix,powers_of_2_table_B875]
	add.w	d3,a2                            	| [$b6cc: add  ix,de]

	move.b	(a2),d0                    	| [$b6ce: ld   a,(ix+$00)]
	move.b	d0,d1                           	| [$b6d1: ld   b,a]
	and.b	(a0),d0							| [and  (hl)]
	jeq	l_b726                             	| [$b6d3: jp   z,$B726]
											| [$b6d6: ld   de,$0006] 6
	addq.w	#6,a0                            	| [$b6d9: add  hl,de]
	move.b	d1,d0                           	| [$b6da: ld   a,b]
	and.b	(a0),d0							| [and  (hl)]
	jne	l_b726                             	| [$b6dc: jp   nz,$B726]
	move.b	d1,d0                           	| [$b6df: ld   a,b]
												| [$b6e0: ld   de,$000C] 12
	add.w	#0xc,a0                            	| [$b6e3: add  hl,de]

	move.b	d1,d0                           	| [$b6e4: ld   a,b]
	not.b	d0                               	| [$b6e5: cpl]
	and.b	(a0),d0							| [and  (hl)]
	move.b	d0,(a0)                         	| [$b6e7: ld   (hl),a]
	* get pushed hl value in de
	move.l	(sp)+,a1                        	| [$b6e8: pop  de]
	move.w	#0x000C,a0                      	| [$b6e9: ld   hl,$000C]
	* and add 12 to it
	add.l	a1,a0                            	| [$b6ec: add  hl,de]
	move.b	d1,d0                           	| [$b6ed: ld   a,b]
	and.b	(a0),d0							| [and  (hl)]
	jeq	l_b6f9                             	| [$b6ef: jp   z,$B6F9]
	* if condition met, one less task is suspended
	lea	nb_suspended_tasks_C02A(pc),a3     	| [$b6f2: ld   iy,nb_suspended_tasks_C02A]
	subq.b	#1,(0x00,a3)                    	| [$b6f6: dec  (iy+$00)]
l_b6f9:
	move.b	d1,d0                           	| [$b6f9: ld   a,b]
	or.b	(a0),d0                           	| [$b6fa: or   (hl)]
	move.b	d0,(a0)                         	| [$b6fb: ld   (hl),a]
	move.w	(sp)+,d0                        	| [$b6fc: pop  af]
	lea	task_struct_C100(pc),a3                	| [$b6fd: ld   iy,task_struct_C100]
	move.b	d0,d1                           	| [$b701: ld   b,a]
	clr.b	d2                               	| [$b702: ld   c,$00]
	tst.b	d0                               	| [$b704: and  a]
	roxr.b	#1,d1                           	| [$b705: rr   b]
	roxr.b	#1,d2                           	| [$b707: rr   c]
	roxr.b	#1,d1                           	| [$b709: rr   b]
	roxr.b	#1,d2                           	| [$b70b: rr   c]
	roxr.b	#1,d1                           	| [$b70d: rr   b]
	roxr.b	#1,d2                           	| [$b70f: rr   c]
	lsl.w	#8,d1
	move.b	d2,d1
	add.w	d1,a3                            	| [$b711: add  iy,bc]

	move.b	player_2_attack_flags_C028,d0   	| [$b713: ld   a,(player_2_attack_flags_C028)]
	move.b	d0,(0x05,a3)                    	| [$b716: ld   (iy+$05),a]
	movem.w	(sp)+,d1/d2                    	| [$b719: pop  bc]
	move.b	d1,(0x06,a3)                    	| [$b71a: ld   (iy+$06),b]
	lea	nb_suspended_tasks_C02A(pc),a0     	| [$b71d: ld   hl,nb_suspended_tasks_C02A]
	addq.b	#1,(a0)                         	| [$b720: inc  (hl)]
	clr.b	d0                               	| [$b721: xor  a]
	jbsr	enable_interrupts_BBE2            	| [$b722: call enable_interrupts_BBE2]
	rts           

l_b726:
	move.l	(sp)+,a0                        	| [$b726: pop  hl]
	move.w	(sp)+,d0                        	| [$b727: pop  af]
	movem.w	(sp)+,d1/d2                    	| [$b728: pop  bc]
	st.b	d0                                	| [$b729: ld   a,$FF]
	jbsr	enable_interrupts_BBE2            	| [$b72b: call enable_interrupts_BBE2]
	rts                                    	| [$b72e: ret]
	
task_struct_table_B7E5:
	.long	task_struct_C100                           	|  $b7e5
	.long	task_struct_C120                           	|  $b7e7
	.long	task_struct_C140                           	|  $b7e9
	.long	task_struct_C160                           	|  $b7eb
	.long	task_struct_C180                           	|  $b7ed
	.long	task_struct_C1A0                           	|  $b7ef
	.long	task_struct_C1C0                           	|  $b7f1
	.long	task_struct_C1E0                           	|  $b7f3
	.long	task_struct_C200                           	|  $b7f5
	.long	task_struct_C220                           	|  $b7f7
	.long	task_struct_C240                           	|  $b7f9
	.long	task_struct_C260                           	|  $b7fb
	.long	task_struct_C280                           	|  $b7fd
	.long	task_struct_C2A0                           	|  $b7ff
	.long	task_struct_C2C0                           	|  $b801
	.long	task_struct_C2E0                           	|  $b803
	.long	task_struct_C300                           	|  $b805
	.long	task_struct_C320                           	|  $b807
	.long	task_struct_C340                           	|  $b809
	.long	task_struct_C360                           	|  $b80b
	.long	task_struct_C380                           	|  $b80d
	.long	task_struct_C3A0                           	|  $b80f
	.long	task_struct_C3C0                           	|  $b811
	.long	task_struct_C3E0                           	|  $b813
	.long	task_struct_C400                           	|  $b815
	* this is probably not reached, and a mistake
	* as this overlaps the stack buffers
	* let it crash loudly if accessed!!!
	.long	-1   | task_struct_C420                           	|  $b817
	.long	-1   | task_struct_C440                           	|  $b819
	.long	-1   | task_struct_C460                           	|  $b81b
	.long	-1   | task_struct_C480                           	|  $b81d
	.long	-1   | task_struct_C4A0                           	|  $b81f
	.long	-1   | task_struct_C4C0                           	|  $b821
	.long	-1   | task_struct_C4E0                           	|  $b823
task_stack_buffer_table_B825:
	.long	stack_buffer_C420                           	|  $b825
	.long	stack_buffer_C440                           	|  $b827
	.long	stack_buffer_C460                           	|  $b829
	.long	stack_buffer_C480                           	|  $b82b
	.long	stack_buffer_C4A0                           	|  $b82d
	.long	stack_buffer_C4C0                           	|  $b82f
	.long	stack_buffer_C4E0                           	|  $b831
	.long	stack_buffer_C500                           	|  $b833
	.long	stack_buffer_C520                           	|  $b835
	.long	stack_buffer_C540                           	|  $b837
	.long	stack_buffer_C560                           	|  $b839
	.long	stack_buffer_C580                           	|  $b83b
	.long	stack_buffer_C5A0                           	|  $b83d
	.long	stack_buffer_C5C0                           	|  $b83f
	.long	stack_buffer_C5E0                           	|  $b841
	.long	stack_buffer_C600                           	|  $b843
	.long	stack_buffer_C620                           	|  $b845
	.long	stack_buffer_C640                           	|  $b847
	.long	stack_buffer_C660                           	|  $b849
	.long	stack_buffer_C680                           	|  $b84b
	.long	stack_buffer_C6A0                           	|  $b84d
	.long	stack_buffer_C6C0                           	|  $b84f
	.long	stack_buffer_C6E0                           	|  $b851
	.long	stack_buffer_C700                           	|  $b853
	.long	-1   | stack_buffer_C720                           	|  $b855
	.long	-1   | stack_buffer_C740                           	|  $b857
	.long	-1   | stack_buffer_C760                           	|  $b859
	.long	-1   | stack_buffer_C780                           	|  $b85b
	.long	-1   | stack_buffer_C7A0                           	|  $b85d
	.long	-1   | stack_buffer_C7C0                           	|  $b85f
	.long	-1   | stack_buffer_C7E0                           	|  $b861
	.long	-1   | stack_buffer_C800                           	|  $b863
	.long	active_task_bit_table_C000                           	|  $b865
	.long	unknown_C008                           	|  $b867
	.long	unknown_C010                           	|  $b869
	.long	unknown_C018                           	|  $b86b
	.long	unknown_C020                           	|  $b86d
	.long	player_2_attack_flags_C028                           	|  $b86f
	.long	dip_switches_copy_C030                          	|  $b871
	.long	unknown_C038                           	|  $b873


powers_of_2_table_B875:
	dc.b	0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80 | $b875
table_B87D:
	dc.b	0x00,0x00,0x01,0x00,0x02,0x01,0x01,0x00 | $b87d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b885
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $b88d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b895
	dc.b	0x10,0x04,0x01,0x00,0x02,0x01,0x01,0x00 | $b89d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b8a5
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $b8ad
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b8b5
	dc.b	0x20,0x05,0x01,0x00,0x02,0x01,0x01,0x00 | $b8bd
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b8c5
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $b8cd
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b8d5
	dc.b	0x10,0x04,0x01,0x00,0x02,0x01,0x01,0x00 | $b8dd
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b8e5
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $b8ed
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b8f5
	dc.b	0x40,0x06,0x01,0x00,0x02,0x01,0x01,0x00 | $b8fd
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b905
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $b90d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b915
	dc.b	0x10,0x04,0x01,0x00,0x02,0x01,0x01,0x00 | $b91d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b925
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $b92d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b935
	dc.b	0x20,0x05,0x01,0x00,0x02,0x01,0x01,0x00 | $b93d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b945
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $b94d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b955
	dc.b	0x10,0x04,0x01,0x00,0x02,0x01,0x01,0x00 | $b95d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b965
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $b96d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b975
	dc.b	0x80,0x07,0x01,0x00,0x02,0x01,0x01,0x00 | $b97d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b985
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $b98d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b995
	dc.b	0x10,0x04,0x01,0x00,0x02,0x01,0x01,0x00 | $b99d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b9a5
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $b9ad
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b9b5
	dc.b	0x20,0x05,0x01,0x00,0x02,0x01,0x01,0x00 | $b9bd
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b9c5
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $b9cd
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b9d5
	dc.b	0x10,0x04,0x01,0x00,0x02,0x01,0x01,0x00 | $b9dd
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b9e5
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $b9ed
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $b9f5
	dc.b	0x40,0x06,0x01,0x00,0x02,0x01,0x01,0x00 | $b9fd
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $ba05
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $ba0d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $ba15
	dc.b	0x10,0x04,0x01,0x00,0x02,0x01,0x01,0x00 | $ba1d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $ba25
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $ba2d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $ba35
	dc.b	0x20,0x05,0x01,0x00,0x02,0x01,0x01,0x00 | $ba3d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $ba45
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $ba4d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $ba55
	dc.b	0x10,0x04,0x01,0x00,0x02,0x01,0x01,0x00 | $ba5d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $ba65
	dc.b	0x08,0x03,0x01,0x00,0x02,0x01,0x01,0x00 | $ba6d
	dc.b	0x04,0x02,0x01,0x00,0x02,0x01,0x01,0x00 | $ba75

init_ram_BB41:
* clear video ram
	*lea	l_D000(pc),a0                      	| [$bb44: ld   hl,$D000]
	*lea	l_1000(pc),a4                      	| [$bb47: ld   bc,$1000] immediate value
	*jbsr	clear_zone_B2BD                   	| [$bb4a: call clear_zone_B2BD]
* clear ram
	*lea	active_task_bit_table_C000(pc),a0                	| [$bb4d: ld   hl,active_task_bit_table_C000]
	*move.w	#0x1000,d1                      	| [$bb50: ld   bc,$1000] immediate value
	*jbsr	clear_zone_B2BD                   	| [$bb53: call clear_zone_B2BD]
* init ram with some startup values
	jbsr	init_C040_F6E5                    	| [$bb57: call init_C040_F6E5]
	move.b	#0x02,d0                        	| [$bb5a: ld   a,$02]
	move.b	d0,unknown_C0C0                 	| [$bb5c: ld   (unknown_C0C0),a]
	jbsr	get_dip_switches_BB92             	| [$bb5f: call get_dip_switches_BB92]
	move.b	d0,dip_switches_copy_C030       	| [$bb62: ld   (dip_switches_copy_C030),a]
	clr.b	d0                               	| [$bb65: xor  a]
	jbsr	schedule_task_to_start_B620                 	| [$bb66: call schedule_task_to_start_B620]
	move.b	#0x80,d0                        	| [$bb69: ld   a,$80]
	jbsr	stop_sound_BBDF                   	| [$bb6b: call stop_sound_BBDF]
	rts                                    	| [$bb6e: ret]

set_normal_screen_bb72:
	rts

* read system port
check_coin_ports_BB82:
	movem.w	d1/d2,-(sp)                    	| [$bb82: push bc]                       	| [$bb82: push bc]
*in   a,($80)
	moveq	#0,d0		| temp!!
	not.b	d0                               	| [$bb85: cpl]
* only 4 first bits are used
*	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
*	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
*	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START1 )
*	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_START2 )
	and.b	#0x0F,d0                         	| [$bb86: and  $0F]
	move.b	d0,d1                           	| [$bb88: ld   b,a]
	ror.b	#2,d0                            	| [$bb89: rrca] * 2
	and.b	#0xC0,d0                         	| [$bb8b: and  $C0] coin inserted bits
	or.b	d1,d0                             	| [$bb8d: or   b]
	and.b	#0xCC,d0                         	| [$bb8e: and  $CC]
	movem.w	(sp)+,d1/d2                    	| [$bb90: pop  bc]
	rts                                    	| [$bb91: ret]

get_dip_switches_BB92:
	moveq	#0,d0
	*in   a,($C0)
	not.b	d0                               	| [$bb94: cpl] invert bits (active low logic)
	rts                                    	| [$bb95: ret]

disable_interrupts_BBE2:
	jbsr		osd_disable_vblank_interrupt
	rts
	
enable_interrupts_BBE2:
	jbsr		osd_enable_vblank_interrupt
	rts

stop_sound_BBDF:
	jra	osd_sound_stop	| [$bbe1: ret]


* copy contents of ROM in $C040
init_C040_F6E5:
	move.w	#0x006C,d1                      	| [$f6e5: ld   bc,$006C] 108
	lea	table_F6F1(pc),a0                  	| [$f6e8: ld   hl,table_F6F1]
	lea	unknown_C040,a1                	| [$f6eb: ld   de,unknown_C040]
	jbsr	ldir                              	| [$f6ee: ldir]
	rts                                    	| [$f6f0: ret]
table_F6F1:
	dc.b	0x02,0x00,0x00,0x00,0x00,0x00,0x13,0xb0 | table_F6F1
	dc.b	0x1e,0xb0,0x0c,0xb0,0x14,0xb0,0x22,0xb0 | $f6f9
	dc.b	0x00,0x03,0x01,0x80,0x00,0x00,0x00,0x00 | $f701
	dc.b	0x16,0xb0,0x0a,0xb0,0x1b,0xb0,0x22,0xb0 | $f709
	dc.b	0x3c,0xb0,0x00,0x02,0x01,0x60,0x00,0x00 | $f711
	dc.b	0x00,0x00,0x14,0xb0,0x1e,0xb0,0x17,0xb0 | $f719
	dc.b	0x1d,0xb0,0x0a,0xb0,0x00,0x02,0x01,0x40 | $f721
	dc.b	0x00,0x00,0x00,0x00,0x1b,0xb0,0x0e,0xb0 | $f729
	dc.b	0x12,0xb0,0x14,0xb0,0x18,0xb0,0x00,0x01 | $f731
	dc.b	0x01,0x20,0x00,0x00,0x00,0x00,0x13,0xb0 | $f739
	dc.b	0x18,0xb0,0x17,0xb0,0x22,0xb0,0x3c,0xb0 | $f741
	dc.b	0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00 | $f749
	dc.b	0x2f,0xb0,0x2f,0xb0,0x2f,0xb0,0x2f,0xb0 | $f751
	dc.b	0x2f,0xb0,0x00,0x01 | $f759
	

* < A0: source (HL)
* < A1: destination (DE)
* < D1: length (16 bit)
ldir:
    subq.w    #1,d1
0:
    move.b    (a0)+,(a1)+
    dbf        d1,0b
    clr.w    d1
    rts
